<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Seller Dashboard â€” Marketplace</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* ===== MOBILE-FIRST RESPONSIVE CSS ===== */
  :root {
    --primary: #2563eb; --success: #10b981; --warn: #f59e0b; --danger: #ef4444;
    --light-bg: #f9fafb; --dark-bg: #0f172a; --card: #fff; --card-dark: #1e293b;
    --text-dark: #1e293b; --text-light: #f8fafc; --muted: #64748b;
    --radius: 8px; --trans: all 0.2s ease;
    --excel-border: #c9d4e8;
    --badge-bg: #ef4444;
  }

  * {
    box-sizing: border-box;
  }

  body {
    font-family: Inter, Arial, sans-serif;
    margin: 0;
    background: var(--light-bg);
    color: var(--text-dark);
    padding: 12px;
    transition: var(--trans);
    font-size: 14px;
    line-height: 1.4;
  }

  body.dark-mode {
    background: var(--dark-bg);
    color: var(--text-light);
  }

  .container {
    max-width: 1200px;
    margin: 0 auto;
    width: 100%;
  }

  /* ===== HEADER ===== */
  .header {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-bottom: 16px;
  }

  .title {
    display: flex;
    align-items: flex-start;
    gap: 10px;
  }

  .title h1 {
    font-size: 1.3rem;
    margin: 0;
    color: var(--primary);
    line-height: 1.2;
  }

  .small-muted {
    font-size: 0.8rem;
    color: var(--muted);
    line-height: 1.3;
  }

  .user-controls {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: space-between;
  }

  .icon-btn {
    background: transparent;
    border: none;
    padding: 6px;
    border-radius: 6px;
    cursor: pointer;
    color: inherit;
    font-size: 0.9rem;
  }

  .avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid rgba(0, 0, 0, 0.06);
  }

  .profile-dropdown {
    position: relative;
  }

  .dropdown-menu {
    position: absolute;
    right: 0;
    top: 42px;
    background: var(--card);
    border-radius: 6px;
    padding: 6px 0;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    display: none;
    min-width: 160px;
    z-index: 100;
  }

  body.dark-mode .dropdown-menu {
    background: var(--card-dark);
  }

  .dropdown-menu a {
    display: block;
    padding: 8px 12px;
    color: inherit;
    text-decoration: none;
    font-size: 0.85rem;
  }

  .dropdown-menu a:hover {
    background: rgba(0, 0, 0, 0.04);
  }

  /* ===== CONTROLS ROW ===== */
  .controls-row {
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: stretch;
    margin-bottom: 12px;
  }

  /* ===== SECTIONS & CARDS ===== */
  .section {
    background: var(--card);
    border-radius: var(--radius);
    padding: 12px;
    margin-bottom: 16px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
    transition: var(--trans);
    overflow: hidden;
  }

  body.dark-mode .section {
    background: var(--card-dark);
  }

  .section h2 {
    margin: 0 0 8px 0;
    font-size: 1rem;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  /* ===== BADGE FOR NEW ORDERS ===== */
  .section .new-badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    margin-left: 6px;
  }

  .new-badge .dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: var(--badge-bg);
    position: relative;
    box-shadow: 0 0 6px rgba(239, 68, 68, 0.6);
  }

  .new-badge .count {
    background: var(--badge-bg);
    color: #fff;
    padding: 3px 6px;
    border-radius: 999px;
    font-weight: 700;
    font-size: 0.75rem;
    min-width: 22px;
    text-align: center;
  }

  @keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.6); }
    70% { box-shadow: 0 0 0 6px rgba(239, 68, 68, 0); }
    100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
  }

  .new-badge .dot.pulse {
    animation: pulse 1.6s infinite;
  }

  /* ===== TABLE (EXCEL-LIKE GRID) ===== */
  .table-wrap {
    overflow: auto;
    -webkit-overflow-scrolling: touch;
    border: 1px solid var(--excel-border);
    border-radius: var(--radius);
  }

  table {
    width: 100%;
    border-collapse: collapse;
    min-width: 600px;
    background: transparent;
    font-size: 0.85rem;
  }

  th, td {
    padding: 8px 10px;
    border: 1px solid var(--excel-border);
    text-align: left;
    vertical-align: middle;
  }

  th {
    background: #f3fdff;
    font-weight: 600;
    font-size: 0.8rem;
  }

  body.dark-mode th, body.dark-mode td {
    border-color: rgba(255, 255, 255, 0.06);
  }

  tr:hover td {
    background: rgba(0, 0, 0, 0.02);
  }

  .status-badge {
    padding: 4px 8px;
    border-radius: 10px;
    font-weight: 700;
    font-size: 0.75rem;
    display: inline-block;
  }

  .s-pending { background: #fff7ed; color: #92400e; }
  .s-accepted { background: #dbeafe; color: #1e40af; }
  .s-processing { background: #fff3bf; color: #92400e; }
  .s-delivering { background: #d1fae5; color: #065f46; }
  .s-atdoor { background: #fef3c7; color: #92400e; }
  .s-delivered { background: #dcfce7; color: #065f46; }
  .s-rejected { background: #fecaca; color: #7f1d1d; }

  /* ===== ACTIONS ===== */
  .actions {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
  }

  .btn {
    padding: 6px 8px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    font-weight: 600;
    font-size: 0.8rem;
    white-space: nowrap;
  }

  .btn-edit { background: var(--primary); color: #fff; }
  .btn-delete { background: var(--danger); color: #fff; }
  .btn-accept { background: var(--success); color: #fff; }
  .btn-warn { background: var(--warn); color: #fff; }
  .btn-muted { background: transparent; border: 1px solid #e6eefc; }

  /* ===== ORDER DETAILS EXPANDED PANE ===== */
  .order-details {
    margin-top: 8px;
    padding: 10px;
    border-radius: 6px;
    background: var(--light-bg);
    display: none;
    border: 1px solid var(--excel-border);
    font-size: 0.85rem;
  }

  body.dark-mode .order-details {
    background: rgba(255, 255, 255, 0.03);
  }

  .order-items {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .order-item {
    display: flex;
    gap: 10px;
    align-items: center;
  }

  .item-thumb {
    width: 50px;
    height: 50px;
    border-radius: 6px;
    object-fit: cover;
    border: 1px solid #e6eefc;
  }

  /* ===== THUMBNAIL IN LIST ===== */
  .row-thumb {
    width: 40px;
    height: 40px;
    border-radius: 5px;
    object-fit: cover;
    border: 1px solid #e6eefc;
    margin-right: 8px;
    vertical-align: middle;
  }

  /* ===== MODAL ===== */
  .modal {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.45);
    z-index: 999;
    padding: 12px;
  }

  .modal-card {
    background: var(--card);
    padding: 16px;
    border-radius: 8px;
    width: 100%;
    max-width: 420px;
    max-height: 90vh;
    overflow-y: auto;
  }

  body.dark-mode .modal-card {
    background: var(--card-dark);
  }

  .modal-card h3 {
    margin: 0 0 8px 0;
    font-size: 1.1rem;
  }

  .input, select {
    width: 100%;
    padding: 10px;
    border-radius: 6px;
    border: 1px solid #e6eefc;
    margin-top: 8px;
    font-size: 0.9rem;
  }

  /* ===== TOAST ===== */
  #toastContainer {
    position: fixed;
    right: 12px;
    bottom: 12px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 1000;
    max-width: calc(100vw - 24px);
  }

  .toast {
    padding: 8px 12px;
    border-radius: 6px;
    color: #fff;
    min-width: 200px;
    max-width: 280px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
    font-size: 0.85rem;
  }

  .toast-success { background: var(--success); }
  .toast-error { background: var(--danger); }
  .toast-warn { background: var(--warn); }

  /* ===== ANALYTICS GRID ===== */
  .analytics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 10px;
    margin-top: 12px;
  }

  .analytics-item {
    text-align: center;
    padding: 10px;
    background: var(--light-bg);
    border-radius: var(--radius);
  }

  body.dark-mode .analytics-item {
    background: rgba(255, 255, 255, 0.05);
  }

  .analytics-item strong {
    display: block;
    font-size: 0.85rem;
    margin-bottom: 4px;
  }

  /* ===== MEDIA QUERIES ===== */

  /* Small phones (up to 360px) */
  @media (max-width: 360px) {
    body {
      padding: 8px;
      font-size: 13px;
    }

    .section {
      padding: 10px;
    }

    .user-controls {
      gap: 6px;
    }

    .btn {
      padding: 5px 7px;
      font-size: 0.75rem;
    }

    table {
      min-width: 500px;
      font-size: 0.8rem;
    }

    th, td {
      padding: 6px 8px;
    }
  }

  /* Medium phones (361px to 480px) */
  @media (min-width: 361px) and (max-width: 480px) {
    .user-controls {
      justify-content: flex-start;
    }

    .controls-row {
      flex-direction: row;
      flex-wrap: wrap;
    }
  }

  /* Large phones (481px to 767px) */
  @media (min-width: 481px) {
    .header {
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
    }

    .controls-row {
      flex-direction: row;
      align-items: center;
    }

    .user-controls {
      justify-content: flex-end;
    }
  }

  /* Tablets and larger (768px+) */
  @media (min-width: 768px) {
    body {
      padding: 16px;
      font-size: 14px;
    }

    .section {
      padding: 16px;
    }

    .title h1 {
      font-size: 1.5rem;
    }

    .controls-row {
      flex-direction: row;
      align-items: center;
    }

    table {
      min-width: 680px;
      font-size: 0.85rem;
    }

    th, td {
      padding: 10px 12px;
    }

    .btn {
      padding: 8px 10px;
      font-size: 0.8rem;
    }
  }

  /* Desktop (900px+) */
  @media (min-width: 900px) {
    .analytics-grid {
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }
  }

  /* ===== UTILITY CLASSES ===== */
  .text-center { text-align: center; }
  .text-left { text-align: left; }
  .text-right { text-align: right; }
  .mb-1 { margin-bottom: 8px; }
  .mb-2 { margin-bottom: 16px; }
  .mt-1 { margin-top: 8px; }
  .mt-2 { margin-top: 16px; }
  .hidden { display: none; }
  .flex { display: flex; }
  .flex-col { flex-direction: column; }
  .items-center { align-items: center; }
  .justify-between { justify-content: space-between; }
  .gap-1 { gap: 8px; }
  .gap-2 { gap: 16px; }
  .w-full { width: 100%; }

  /* ===== VALIDATION STYLES ===== */
  .input:invalid {
    border-color: var(--danger);
    box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.1);
  }

  .input:focus:invalid {
    border-color: var(--danger);
    box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);
  }

  .validation-message {
    color: var(--danger);
    font-size: 0.75rem;
    margin-top: 4px;
    display: none;
  }

  .input:invalid + .validation-message {
    display: block;
  }
  </style>
</head>
<body>
<div class="container">
  <div class="header">
    <div class="title">
      <i class="fas fa-store" style="font-size:1.4rem;color:var(--primary)"></i>
      <div>
        <h1>Seller Dashboard</h1>
        <div class="small-muted">Marketplace â€” Manage orders (simple flow)</div>
      </div>
    </div>

    <div class="user-controls">
      <button id="openAdd" class="btn btn-edit"><i class="fas fa-plus"></i>&nbsp;Add Product</button>
      <button id="resetData" class="btn btn-warn" title="Clear all test data"><i class="fas fa-trash-alt"></i>&nbsp;Reset Data</button>
      <button id="toggleTheme" class="icon-btn" title="Toggle theme"><i class="fas fa-moon"></i></button>
      <div class="profile-dropdown">
        <img id="userAvatar" class="avatar" src="../../images/no profile pic.jpg" alt="profile">
        <div class="dropdown-menu" id="profileMenu">
          <a href="../profile/profile.html"><i class="fas fa-user"></i>Profile</a>
          <a href="../shopping/orders/orders.html"><i class="fas fa-box"></i>Orders</a>
          <a href="../delivery/delivery.html"><i class="fas fa-shipping-fast"></i>Carriers</a>
          <a href="../market/market.html"><i class="fas fa-store"></i>Guild Forge</a>
          <a href="../shopping/cart/cart.html"><i class="fas fa-shopping-cart"></i>Cart</a>
          <a href="../community/community.html"><i class="fas fa-users"></i>Guild Hall</a>
          <a href="../map/map.html"><i class="fas fa-map-marker-alt"></i>Map</a>
          <div style="height:1px;background:#eee;margin:6px 0"></div>
          <a href="#" id="logoutBtn"><i class="fas fa-sign-out-alt"></i>Leave Guildite</a>
        </div>
      </div>
    </div>
  </div>

  <!-- Products -->
  <section class="section" id="sectionProducts">
    <h2><i class="fas fa-box-open"></i>&nbsp; My Listings</h2>
    <div class="controls-row">
      <input id="productSearch" class="input" placeholder="Search products by name..." style="max-width:320px">
      <select id="productStatusFilter" class="input" style="max-width:200px">
        <option value="">All product status</option>
        <option>Active</option>
        <option>Out of Stock</option>
      </select>
      <select id="productCategoryFilter" class="input" style="max-width:200px">
        <option value="">All categories</option>
      </select>
    </div>
    <div class="table-wrap">
      <table id="prodTable">
        <thead>
          <tr><th>Product</th><th>Price</th><th>Quantity</th><th>Condition</th><th>Category</th><th>Status</th><th>Added</th><th>Actions</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <!-- Orders -->
  <section class="section" id="sectionOrders">
    <h2>
      <i class="fas fa-shopping-cart"></i>&nbsp; Customer Orders
      <span class="new-badge" id="ordersBadge" title="Active orders" style="display:none">
        <span class="dot pulse" id="ordersDot"></span>
        <span class="count" id="ordersCount">0</span>
      </span>
    </h2>
    <div class="controls-row">
      <input id="orderSearch" class="input" placeholder="Search by buyer or product..." style="max-width:320px">
      <select id="orderFilterSelect" class="input" style="max-width:220px">
        <option value="">All order status</option>
        <option>Pending</option>
        <option>Accepted</option>
        <option>Processing</option>
        <option>Delivering</option>
        <option>At Door</option>
        <option>Delivered</option>
        <option>Rejected</option>
      </select>
    </div>

    <div class="table-wrap">
      <table id="ordersTable">
        <thead><tr><th>Order ID</th><th>Buyer</th><th>Product(s)</th><th>Qty</th><th>Status</th><th>Actions</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <!-- Completed / History -->
  <section class="section" id="sectionHistory">
    <h2><i class="fas fa-history"></i>&nbsp; Completed Orders (History)</h2>
    <div class="controls-row">
      <input id="historySearch" class="input" placeholder="Search completed orders..." style="max-width:320px">
      <div style="margin-left:auto;display:flex;gap:8px">
        <button id="exportCsv" class="btn btn-edit"><i class="fas fa-file-csv"></i>&nbsp;Export CSV</button>
        <button id="clearHistory" class="btn btn-warn"><i class="fas fa-trash"></i>&nbsp;Clear History</button>
      </div>
    </div>
    <div class="table-wrap">
      <table id="completedTable">
        <thead>
          <tr><th>Order ID</th><th>Buyer</th><th>Product(s)</th><th>Qty</th><th>Total</th><th>Delivered At</th><th>Actions</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <!-- Analytics -->
  <section class="section" id="sectionAnalytics">
    <h2><i class="fas fa-chart-line"></i>&nbsp; Sales Analytics</h2>
    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:12px;margin-top:12px">
      <div><strong>Total Sales</strong><div id="cardTotal" class="small-muted">GHC 0</div></div>
      <div><strong>Orders</strong><div id="cardOrders" class="small-muted">0</div></div>
      <div><strong>Pending</strong><div id="cardPending" class="small-muted">0</div></div>
      <div><strong>Active Listings</strong><div id="cardActive" class="small-muted">0</div></div>
      <div><strong>Total Stock</strong><div id="cardStock" class="small-muted">0</div></div>
    </div>
  </section>

</div>

<!-- Product modal -->
<div class="modal" id="productModal" aria-hidden="true">
  <div class="modal-card" role="dialog" aria-modal="true">
    <h3 id="productModalTitle">Add product</h3>
    <input id="pName" class="input" placeholder="Product name">
    <input id="pPrice" class="input" type="number" placeholder="Price (GHC)" min="0" step="0.01">
    <input id="pQuantity" class="input" type="number" placeholder="Quantity" min="0" step="1" onkeydown="return event.keyCode !== 69 && event.keyCode !== 189">
    <select id="pCondition" class="input">
      <option>New</option><option>Good</option><option>Fair</option><option>Poor</option>
    </select>

    <!-- CATEGORY SELECT (predefined only) -->
    <select id="pCategory" class="input" style="margin-top:8px">
      <option value="">Uncategorized</option>
    </select>
    
    <label for="pDescription">Description</label>
    <textarea id="pDescription" rows="1" placeholder="Enter product description"></textarea>


    <select id="pStatus" class="input" style="margin-top:8px">
      <option>Active</option><option>Out of Stock</option>
    </select>
    <div style="margin-top: 8px;">
  <label class="small-muted">Product Image</label>
  <input id="pImage" class="input" type="file" accept="image/*">
  <div class="small-muted" style="font-size: 0.75rem; margin-top: 4px;">
    All formats supported â€¢ Auto-optimized for best quality â€¢ Max 10MB
  </div>
</div>
    <img id="pPreview" style="width:96px;height:96px;border-radius:8px;object-fit:cover;display:none;margin-top:8px" alt="preview">
    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
      <button id="pCancel" class="btn">Cancel</button>
      <button id="pSave" class="btn btn-edit">Save product</button>
    </div>
    
  </div>
</div>

<!-- Delivery code modal -->
<div id="codeModal" class="modal" style="display:none">
  <div class="modal-card">
    <h3>Enter Delivery Code</h3>
    <div class="small-muted">Ask the buyer for the delivery code and enter it here to confirm delivery.</div>
    <input id="deliveryCodeInput" class="input" placeholder="6-digit code">
    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px">
      <button id="cancelDelivery" class="btn btn-warn">Cancel</button>
      <button id="confirmDelivery" class="btn btn-accept">Confirm</button>
    </div>
  </div>
</div>

<!-- Toasts -->
<div id="toastContainer" aria-live="polite"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-app.js";
import { getDatabase, ref, get, set } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-database.js";
import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-auth.js";
// ADD THESE 4 LINES AT THE TOP
import { 
  getFirestore,       // This is your cloud toy box
  doc,                // This finds a specific toy in the box
  setDoc,             // This puts a toy in the cloud box
  getDoc,             // This gets a toy from the cloud box
  serverTimestamp     // This puts a time sticker on the toy
} from "https://www.gstatic.com/firebasejs/10.11.1/firebase-firestore.js";

// --- Firebase Config ---
const firebaseConfig = {
  apiKey: "AIzaSyBzPa671GH71UvTcZ3dECFPrW4xe1vS9ds",
  authDomain: "marketplace-e0bff.firebaseapp.com",
  projectId: "marketplace-e0bff",
  storageBucket: "marketplace-e0bff.appspot.com",
  messagingSenderId: "892936444768",
  appId: "1:892936444768:web:f595b3a3e5d697988e1c05",
  databaseURL: "https://marketplace-e0bff-default-rtdb.europe-west1.firebasedatabase.app"
};

// --- Init ---
const app = initializeApp(firebaseConfig);
const database = getDatabase(app);
const auth = getAuth(app);
// ADD THIS LINE after const auth = getAuth(app);
const firestore = getFirestore(app); // ðŸ§¸ This opens your cloud toy box

// ðŸ“¦ COPY-PASTE THIS WHOLE SECTION AFTER YOUR firestore line

// ðŸŽ¯ Function 1: Put toy in cloud box
async function mirrorLocalToCloud(uid, toyName, value) {
  try {
    // uid = your user ID
    // toyName = "products", "orders", etc.
    // value = your data as JSON string
    
    await setDoc(doc(firestore, 'users', uid, 'toys', toyName), {
      value: value,  // Your data
      key: `${toyName}_${uid}`,
      updatedAt: serverTimestamp(), // Time sticker
      localUpdated: new Date().toISOString()
    });
    console.log("ðŸ’¾ Saved to cloud:", toyName);
  } catch (error) {
    console.log("ðŸ’¾ Cloud save failed:", error.message);
  }
}

// ðŸŽ¯ Function 2: Get toy from cloud box
async function restoreFromCloud(uid, toyName) {
  try {
    const docSnap = await getDoc(doc(firestore, 'users', uid, 'toys', toyName));
    
    if (docSnap.exists()) {
      const cloudData = docSnap.data();
      console.log("ðŸ“¥ Loaded from cloud:", toyName);
      return cloudData.value ? JSON.parse(cloudData.value) : null;
    }
  } catch (error) {
    console.log("ðŸ“¥ Cloud load failed:", error.message);
  }
  return null;
}

// ðŸŽ¯ Function 3: Save to local AND cloud at same time (including RTDB for market page)
async function saveWithCloudSync(key, data) {
  const uid = getUid(); // Get your user ID
  const value = JSON.stringify(data || []);
  
  // 1. Save to local storage (fast)
  localStorage.setItem(key, value);
  
  // 2. Save to Firestore (for user's private cloud storage)
  if (uid && uid !== 'anon') {
    // Convert "products__seller__123" â†’ "products"
    const toyName = key.split('__')[0];
    mirrorLocalToCloud(uid, toyName, value);
    
    // 3. ALSO save to RTDB products node so market page can see them!
    if (toyName === 'products' && Array.isArray(data)) {
      try {
        // Sync each product to RTDB products node
        for (const product of data) {
          if (product && product.id) {
            const productRef = ref(database, `products/${product.id}`);
            await set(productRef, {
              ...product,
              sellerId: uid,
              lastSynced: new Date().toISOString()
            });
          }
        }
        console.log(`âœ… Synced ${data.length} products to RTDB for market page`);
      } catch (error) {
        console.error('âŒ Failed to sync products to RTDB:', error);
      }
    }
  }
}

async function uploadToCloudinary(blob, fileName) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 15000);
  
  try {
    const formData = new FormData();
    formData.append('file', blob, fileName);
    formData.append('upload_preset', 'ml_default');
    formData.append('cloud_name', 'dsj9imkpp');
    
    const response = await fetch(`https://api.cloudinary.com/v1_1/dsj9imkpp/image/upload`, {
      method: 'POST',
      body: formData,
      signal: controller.signal
    });
    
    clearTimeout(timeoutId);
    
    if (!response.ok) throw new Error(`Upload failed`);
    
    const data = await response.json();
    return data.secure_url;
    
  } catch (error) {
    clearTimeout(timeoutId);
    
    if (error.name === 'AbortError') {
      throw new Error('Upload timed out (slow connection)');
    } else if (error.message.includes('Failed to fetch')) {
      throw new Error('Network error - check connection');
    }
    throw error;
  }
}

/* ====== NAMESPACE / UID HELPERS ====== */

// detect page role (we're on seller dashboard so default to seller)
function detectPageRole() {
  try { return (document?.body?.dataset?.role || '').toLowerCase() || (window.location.pathname||'').toLowerCase().includes('testsell') ? 'seller' : 'buyer'; }
  catch(e){ return 'seller'; }
}

// get current signed-in uid (sessionStorage set during auth elsewhere)
function getUid() { 
  // fallback to firebase auth current user if session storage missing
  try { return sessionStorage.getItem('uid') || (auth.currentUser && auth.currentUser.uid) || null; } 
  catch(e){ return sessionStorage.getItem('uid'); }
}

// make namespaced key: base__role__uid
function nsKey(base, { role=null, uid=null } = {}) {
  const r = role || detectPageRole() || 'seller';
  const u = uid || getUid() || 'anon';
  return `${String(base)}__${String(r)}__${String(u)}`;
}

// helpers for common keys used across pages
function productsKey(){ return nsKey('products'); }
function ordersKey(){ return nsKey('orders'); }
function cartKey(){ return nsKey('cart'); }
function wishlistKey(){ return nsKey('wishlist'); }
function completedOrdersKey(){ return nsKey('completedOrders'); }

// safe read/write JSON
function readJson(k, fallback = []) {
  try { return JSON.parse(localStorage.getItem(k) || JSON.stringify(fallback)); }
  catch(e){ return fallback; }
}
function writeJson(k, data) {
  try { localStorage.setItem(k, JSON.stringify(data || [])); }
  catch(e){ console.warn('writeJson failed', e); }
}

/* ---------- Helper: fetch seller info live by UID ---------- */
async function getSellerInfo(uid) {
  if (!uid) return null;
  try {
    const userRef = ref(database, `users/${uid}`);
    const snap = await get(userRef);
    return snap.exists() ? snap.val() : null;
  } catch (err) {
    console.error("Error fetching seller info:", err);
    return null;
  }
}
const ORDERS_GLOBAL = "orders_global";

// --- ADD THESE TWO FUNCTIONS ---
function getGlobalOrders() {
  try {
    return JSON.parse(localStorage.getItem(ORDERS_GLOBAL)) || [];
  } catch(e) {
    return [];
  }
}

function saveGlobalOrders(data) {
  try {
    localStorage.setItem(ORDERS_GLOBAL, JSON.stringify(data || []));
  } catch(e) {
    console.warn('saveGlobalOrders failed', e);
  }
}
// --- END OF ADDED FUNCTIONS ---


// --- DOM ---
const avatarEl = document.getElementById('userAvatar');
const logoutBtn = document.getElementById('logoutBtn');

// --- Auth Handling ---
// --- Auth Handling ---
onAuthStateChanged(auth, async (user) => {
  if (!user) {
    window.location.href = "../../index.html";
    return;
  }

  // Get user ID
  const uid = user.uid;
  
  // ðŸŽ¯ STEP 1: FIRST check RTDB permissions (banned/declined)
  const userRef = ref(database, `users/${user.uid}`);
  const snapshot = await get(userRef);

  if (!snapshot.exists()) {
    window.location.href = "../../index.html";
    return;
  }

  const userData = snapshot.val();

  // Security checks
  if (userData.declined) {
    window.location.href = "../../adminlogic/declined/declined.html";
    return;
  }
  if (userData.banned) {
    window.location.href = "../../adminlogic/banned/banned.html";
    return;
  }

  // âœ… Update avatar (seller dashboard)
  if (avatarEl) {
    avatarEl.src = userData.profilePictureUrl || "../../images/no profile pic.jpg";
    avatarEl.alt = (userData.name || "User") + "'s profile picture";
  }
  
  // ðŸŽ¯ STEP 2: Setup local toy boxes if empty
  try {
    // Check each toy box
    const toys = [
      { key: productsKey(), default: [] },
      { key: ordersKey(), default: [] },
      { key: completedOrdersKey(), default: [] },
      { key: cartKey(), default: [] },
      { key: wishlistKey(), default: [] }
    ];
    
    for (const toy of toys) {
      if (!localStorage.getItem(toy.key)) {
        localStorage.setItem(toy.key, JSON.stringify(toy.default));
      }
    }
  } catch(e){ 
    console.warn('init seller boxes failed', e); 
  }

  // ðŸŽ¯ STEP 3: LOAD FROM CLOUD (Most Important!)
  try {
    console.log("ðŸ” Looking for cloud toys for user:", uid);
    
    // List of toys to check in cloud
    const cloudToys = ['products', 'orders', 'completedOrders'];
    
    for (const toyName of cloudToys) {
      console.log(`ðŸ“¥ Checking cloud for: ${toyName}`);
      
      // Try to get from cloud
      const cloudData = await restoreFromCloud(uid, toyName);
      
      if (cloudData) {
        console.log(`âœ… Found ${toyName} in cloud! Loading...`);
        
        // Save to local storage with correct key
        let localKey;
        if (toyName === 'products') localKey = productsKey();
        else if (toyName === 'orders') localKey = ordersKey();
        else if (toyName === 'completedOrders') localKey = completedOrdersKey();
        
        localStorage.setItem(localKey, JSON.stringify(cloudData));
        console.log(`ðŸ“¦ Loaded ${toyName} from cloud to ${localKey}`);
      } else {
        console.log(`ðŸ“­ No ${toyName} in cloud yet, using local`);
      }
    }
    
    console.log("âœ… Cloud sync check complete!");
    
    // ðŸŽ¯ Refresh displays with loaded data
    if (typeof renderProducts === 'function') {
      products = JSON.parse(localStorage.getItem(productsKey()) || '[]');
      renderProducts();
    }
    
    if (typeof renderOrders === 'function') {
      orders = JSON.parse(localStorage.getItem(ordersKey()) || '[]');
      renderOrders();
    }
    
    if (typeof renderCompletedOrders === 'function') {
      completedOrders = JSON.parse(localStorage.getItem(completedOrdersKey()) || '[]');
      renderCompletedOrders();
    }
    
  } catch (cloudError) {
    console.warn("âš ï¸ Cloud load failed, continuing with local:", cloudError);
  }
  
});
// --- Logout ---
if (logoutBtn) {
  logoutBtn.addEventListener("click", async (e) => {
    e.preventDefault();
    await signOut(auth);
    window.location.href = "../../index.html";
  });
}

/* ---------- Utilities ---------- */
const qs = s => document.querySelector(s);
const qsa = s => Array.from(document.querySelectorAll(s));
const nowISO = () => new Date().toISOString();
const fmtDate = iso => iso ? new Date(iso).toLocaleString() : '';
const escapeHtml = s => String(s || '').replace(/[&<>"'`=\/]/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;','/':'&#x2F;','`':'&#x60;','=':'&#x3D;'})[ch]);

/* ---------- Predefined categories (admins only can change these offline) ---------- */
const PREDEFINED_CATEGORIES = ['Food','Books','Electronics','Others','Services','Clothing'];

/* ---------- Data (localStorage) ---------- */
let products = JSON.parse(localStorage.getItem(productsKey()) || '[]');
let orders   = JSON.parse(localStorage.getItem(ordersKey()) || '[]');
let completedOrders = JSON.parse(localStorage.getItem(completedOrdersKey()) || '[]');

/* ensure default fields exist on orders */
function normalizeOrderFields(o){
  if (!o) return o;
  if (!Array.isArray(o.bidders)) o.bidders = [];
  if (!o.history) o.history = [];
  if (typeof o.attempts === 'undefined') o.attempts = 0;
  if (typeof o.requestActive === 'undefined') o.requestActive = false;
  if (typeof o.ownerIsDelivering === 'undefined') o.ownerIsDelivering = false;
  return o;
}

// SHARED STORAGE FOR DELIVERY REQUESTS - Add this to both files

// Public area where all delivery requests are posted
function publicDeliveryRequestsKey() {
  return 'public_delivery_requests';
}

// Get all open delivery requests (for delivery guys)
function getPublicDeliveryRequests() {
  try {
    return JSON.parse(localStorage.getItem(publicDeliveryRequestsKey()) || '[]');
  } catch (e) {
    return [];
  }
}

// Save delivery requests to public area
function savePublicDeliveryRequests(requests) {
  try {
    localStorage.setItem(publicDeliveryRequestsKey(), JSON.stringify(requests));
    // Notify all tabs/pages about the update
    window.dispatchEvent(new Event('publicDeliveryRequestsUpdated'));
  } catch (e) {
    console.warn('Failed to save public delivery requests', e);
  }
}

/* ---------- DOM elements ---------- */
const prodTbody = qs('#prodTable tbody');
const ordersTbody = qs('#ordersTable tbody');
const completedTbody = qs('#completedTable tbody');
const productSearch = qs('#productSearch');
const productStatusFilter = qs('#productStatusFilter');
const orderSearch = qs('#orderSearch');
const orderFilter = qs('#orderFilterSelect');
const historySearch = qs('#historySearch');

const openAdd = qs('#openAdd'), toggleTheme = qs('#toggleTheme'), profileMenu = qs('#profileMenu'), avatar = qs('#userAvatar');
const resetDataBtn = qs('#resetData');

const productModal = qs('#productModal'), pName = qs('#pName'), pPrice = qs('#pPrice'), pQuantity = qs('#pQuantity'),
      pCondition = qs('#pCondition'), pStatus = qs('#pStatus'), pImage = qs('#pImage'), pPreview = qs('#pPreview'),
      pCancel = qs('#pCancel'), pSave = qs('#pSave'), productModalTitle = qs('#productModalTitle'),
      pCategory = qs('#pCategory'), pDescription = qs('#pDescription');

const codeModal = qs('#codeModal'), deliveryCodeInput = qs('#deliveryCodeInput'), confirmDeliveryBtn = qs('#confirmDelivery'), cancelDeliveryBtn = qs('#cancelDelivery');

const toastContainer = qs('#toastContainer');

const ordersBadge = qs('#ordersBadge');
const ordersCountEl = qs('#ordersCount');
const ordersDot = qs('#ordersDot');
const exportCsvBtn = qs('#exportCsv');
const clearHistoryBtn = qs('#clearHistory');

const productCategoryFilter = qs('#productCategoryFilter');

// ============================================
// ðŸŽ¯ REAL-TIME QUANTITY VALIDATION
// ============================================

// Add real-time quantity validation
pQuantity && pQuantity.addEventListener('input', function(e) {
  let value = parseInt(this.value) || 0;
  
  // If value is negative, set to 0
  if (value < 0) {
    this.value = 0;
    showToast('âš ï¸ Quantity set to 0 (cannot be negative)', 'warn');
  }
  
  // If not a whole number, round down
  if (!Number.isInteger(value)) {
    this.value = Math.floor(value);
    showToast('âš ï¸ Quantity must be a whole number', 'warn');
  }
});

// Prevent negative input on keypress
pQuantity && pQuantity.addEventListener('keydown', function(e) {
  // Allow: backspace, delete, tab, escape, enter
  if ([46, 8, 9, 27, 13].includes(e.keyCode) ||
      // Allow: Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X
      (e.keyCode === 65 && e.ctrlKey === true) ||
      (e.keyCode === 67 && e.ctrlKey === true) ||
      (e.keyCode === 86 && e.ctrlKey === true) ||
      (e.keyCode === 88 && e.ctrlKey === true) ||
      // Allow: home, end, left, right
      (e.keyCode >= 35 && e.keyCode <= 39)) {
    return;
  }
  
  // Ensure that it is a number and stop the keypress if not
  if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) && (e.keyCode < 96 || e.keyCode > 105)) {
    e.preventDefault();
  }
});

// Also add for price field to prevent negatives
pPrice && pPrice.addEventListener('input', function(e) {
  let value = parseFloat(this.value) || 0;
  
  if (value < 0) {
    this.value = 0;
    showToast('âš ï¸ Price set to 0 (cannot be negative)', 'warn');
  }
});

/* ---------- Toast ---------- */
function showToast(msg, type='success') {
  const t = document.createElement('div');
  t.className = 'toast ' + (type==='error' ? 'toast-error' : type==='warn' ? 'toast-warn' : 'toast-success');
  t.textContent = msg;
  toastContainer.appendChild(t);
  setTimeout(()=> t.remove(), 3000);
}

/* ---------- Profile menu toggle ---------- */
avatar && avatar.addEventListener('click', e => { e.stopPropagation(); profileMenu.style.display = profileMenu.style.display === 'block' ? 'none' : 'block'; });
document.addEventListener('click', ()=> profileMenu && (profileMenu.style.display = 'none'));

/* ---------- Theme ---------- */
(function initTheme(){
  if (localStorage.getItem('darkMode') === 'enabled') document.body.classList.add('dark-mode');
})();
toggleTheme && toggleTheme.addEventListener('click', ()=> {
  document.body.classList.toggle('dark-mode');
  localStorage.setItem('darkMode', document.body.classList.contains('dark-mode') ? 'enabled' : 'disabled');
});

/* ---------- Reset Data (SELLER PRODUCTS + COMPLETED ORDERS) ---------- */
resetDataBtn && resetDataBtn.addEventListener('click', () => {
  if (!confirm('Clear ALL your posted products and order history? This will remove all products you\'ve listed and all your completed orders. This cannot be undone.')) return;
  
  try {
    // Clear seller's products and completed orders
    products = [];
    completedOrders = [];
    
    // Clear seller's products and completed orders from localStorage
    saveWithCloudSync(productsKey(), []); // seller's posted products
    saveWithCloudSync(completedOrdersKey(), []); // seller's completed orders
    
    // Reinitialize empty arrays
    localStorage.setItem(productsKey(), '[]');
    localStorage.setItem(completedOrdersKey(), '[]');
    
    // Clear tracking variables
    localStorage._lastCompletedJson = '[]';
    localStorage._lastProductsJson = '[]';
    
    // Refresh displays
    renderProducts();
    renderCompletedOrders();
    renderAnalytics();
    
    showToast('Your products and order history have been cleared', 'success');
    console.log('âœ… Seller data reset: products and completed orders cleared');
    
  } catch (error) {
    console.error('âŒ Error resetting seller data:', error);
    showToast('Error resetting data', 'error');
  }
});

/* ---------- Clear History (SELLER COMPLETED ORDERS ONLY) ---------- */
clearHistoryBtn && clearHistoryBtn.addEventListener('click', () => { 
  if (!confirm('Clear your completed order history? This will remove all your delivered and rejected orders from history. This cannot be undone.')) return;
  
  try {
    // Clear only seller's completed orders
    completedOrders = [];
    localStorage.setItem(completedOrdersKey(), JSON.stringify([]));
    
    // Update tracking
    localStorage._lastCompletedJson = '[]';
    
    // Refresh displays
    renderCompletedOrders();
    renderAnalytics();
    
    showToast('Your completed order history has been cleared', 'success');
    console.log('âœ… Seller completed orders history cleared');
    
  } catch (error) {
    console.error('âŒ Error clearing seller history:', error);
    showToast('Error clearing history', 'error');
  }
});

/* ---------- Helpers ---------- */
function getProgressStep(status) {
  switch((status||'').toLowerCase()){
    case 'pending': return 1;
    case 'accepted': return 2;
    case 'processing': return 3;
    case 'assigned': return 3; 
    case 'ready for pickup': return 4;  // ðŸ†• PICKUP STEP
    case 'picked up': return 5;         // ðŸ†• PICKUP FINAL STEP
    case 'delivering': return 4;        // Delivery step
    case 'at door': return 5;           // Delivery step  
    case 'delivered': return 6;         // Delivery final step
    default: return 1;
  }
}
// -------------------------
// Seller: reconcile final-status orders and move to completed
// Paste this near the top of the seller script (before renderOrders)
// -------------------------
function isFinalStatus(status) {
  if (!status) return false;
  const s = String(status).toLowerCase();
  return ['delivered','rejected','cancelled','cancel','completed'].includes(s);
}

function reconcileSellerOrders() {
  try {
    const key = ordersKey(); // existing helper in your seller page
    const compKey = (typeof completedOrdersKey === 'function') ? completedOrdersKey() : (`completedOrders__seller__${sessionStorage.getItem('uid')}`);
    let sellerOrders = JSON.parse(localStorage.getItem(key) || '[]') || [];
    let completed = JSON.parse(localStorage.getItem(compKey) || '[]') || [];

    // split
    const remaining = [];
    sellerOrders.forEach(o => {
      if (isFinalStatus(o.status)) {
        // if we already have a copy in completed (avoid dupes by id), skip adding
        const exists = completed.find(c => String(c.id) === String(o.id) || String(c.orderId) === String(o.orderId));
        if (!exists) {
          completed.unshift(o);
        }
      } else {
        remaining.push(o);
      }
    });

    // if something changed, persist back
    // We only write if lengths differ to avoid noise
    const changed = remaining.length !== sellerOrders.length || completed.length > (JSON.parse(localStorage.getItem(compKey) || '[]') || []).length;
    if (changed) {
      localStorage.setItem(key, JSON.stringify(remaining));
      localStorage.setItem(compKey, JSON.stringify(completed));
      // update any quick caches
      if (typeof updateOrdersBadge === 'function') {
        updateOrdersBadge(remaining.filter(o => !isFinalStatus(o.status)).length);
      }
    }
    return { active: remaining, completed };
  } catch (err) {
    console.warn('reconcileSellerOrders failed', err);
    return { active: JSON.parse(localStorage.getItem(ordersKey()) || '[]') || [], completed: JSON.parse(localStorage.getItem((typeof completedOrdersKey === 'function' ? completedOrdersKey() : `completedOrders__seller__${sessionStorage.getItem('uid')}`) ) || '[]') || [] };
  }
}


function statusClass(status){
  const s = (status||'').toLowerCase();
  if (s==='pending') return 's-pending';
  if (s==='accepted') return 's-accepted';
  if (s==='processing') return 's-processing';
  if (s==='ready for pickup') return 's-atdoor';           // ðŸ†• ADD THIS LINE
  if (s==='picked up') return 's-delivered';               // ðŸ†• ADD THIS LINE
  if (s==='delivering') return 's-delivering';
  if (s==='at door') return 's-atdoor';
  if (s==='delivered') return 's-delivered';
  if (s==='rejected') return 's-rejected';
  if (s==='out of stock') return 's-rejected';
  return 's-pending';
}

function updateOrdersBadge(count){
  if (!ordersBadge) return;
  if (count > 0) {
    ordersBadge.style.display = 'inline-flex';
    ordersCountEl.textContent = String(count);
    ordersDot.classList.add('pulse');
  } else {
    hideOrdersBadge();
  }
}
function hideOrdersBadge(){
  if (!ordersBadge) return;
  ordersBadge.style.display = 'none';
  ordersCountEl.textContent = '0';
  ordersDot.classList.remove('pulse');
}

/* ---------- Category selects population (predefined only) ---------- */
function populateCategorySelects(){
  // product modal select
  if (pCategory) {
    const cur = pCategory.value || '';
    pCategory.innerHTML = `<option value="">Uncategorized</option>`;
    PREDEFINED_CATEGORIES.forEach(c => {
      const opt = document.createElement('option');
      opt.value = c;
      opt.textContent = c;
      pCategory.appendChild(opt);
    });
    if (cur) pCategory.value = cur;
  }
  // filter select
  if (productCategoryFilter) {
    const curf = productCategoryFilter.value || '';
    productCategoryFilter.innerHTML = `<option value="">All categories</option>`;
    PREDEFINED_CATEGORIES.forEach(c => {
      const opt = document.createElement('option');
      opt.value = c;
      opt.textContent = c;
      productCategoryFilter.appendChild(opt);
    });
    if (curf) productCategoryFilter.value = curf;
  }
}

/* ---------- Update product status when stock reaches zero ---------- */
function updateProductStatusWhenZero() {
  let updated = false;
  products.forEach(p => {
    const newStatus = (Number(p.quantity) || 0) <= 0 ? 'Out of Stock' : 'Active';
    if (p.status !== newStatus) {
      p.status = newStatus;
      updated = true;
    }
  });
  
  if (updated) {
    saveWithCloudSync(productsKey(), products);
    localStorage._lastProductsJson = localStorage.getItem(productsKey()) || '[]';
    renderProducts();
    showToast('Product statuses updated based on stock levels', 'success');
  }
}

/* ---------- Reduce Product Stock When Order Processing ---------- */
/* ---------- Reduce Product Stock When Order Processing ---------- */
function reduceProductStock(order) {
  try {
    console.log('ðŸ”„ reduceProductStock called for order:', order.id);
    console.log('ðŸ“¦ Order items:', order.items);
    
    // Get products from SELLER'S namespaced storage (not global 'products')
    const sellerProductsKey = productsKey();
    let allProducts = JSON.parse(localStorage.getItem(sellerProductsKey) || '[]');
    console.log('ðŸ“Š Seller products key:', sellerProductsKey);
    console.log('ðŸ“Š Seller products count:', allProducts.length);
    console.log('ðŸ“Š All seller products:', allProducts);
    
    let stockUpdated = false;
    
    // Reduce quantity for each item in the order
    (order.items || []).forEach(orderItem => {
      const productId = String(orderItem.id);
      const orderedQuantity = Number(orderItem.quantity || 1);
      
      console.log(`ðŸ” Looking for product: ${productId}, Qty: ${orderedQuantity}`);
      
      // Find the product - COMPARE AS STRINGS
      const productIndex = allProducts.findIndex(p => String(p.id) === String(productId));
      
      if (productIndex !== -1) {
        const currentStock = Number(allProducts[productIndex].quantity || 0);
        const newStock = Math.max(0, currentStock - orderedQuantity);
        
        console.log(`ðŸ“¦ Found product: "${allProducts[productIndex].name}"`);
        console.log(`ðŸ“¦ Reducing from ${currentStock} to ${newStock}`);
        
        // ACTUALLY REDUCE THE QUANTITY NUMBER
        allProducts[productIndex].quantity = newStock;
        
        // Update status immediately
        allProducts[productIndex].status = newStock <= 0 ? 'Out of Stock' : 'Active';
        stockUpdated = true;
        
        console.log(`âœ… Updated: ${allProducts[productIndex].name} = ${newStock}`);
      } else {
        console.log('âŒ Product not found in seller storage:', productId);
        
        // Debug: Show all product IDs for comparison
        console.log('ðŸ” Available product IDs:', allProducts.map(p => p.id));
      }
    });
    
    // Save the reduced quantities back to SELLER'S storage
    if (stockUpdated) {
      localStorage.setItem(sellerProductsKey, JSON.stringify(allProducts));
      console.log('ðŸ’¾ Saved updated products to seller storage');
      
      // Also try to update global products if they exist
      try {
        const globalProducts = JSON.parse(localStorage.getItem('products') || '[]');
        if (globalProducts.length > 0) {
          // Update global products too
          (order.items || []).forEach(orderItem => {
            const globalIndex = globalProducts.findIndex(p => String(p.id) === String(orderItem.id));
            if (globalIndex !== -1) {
              globalProducts[globalIndex].quantity = Math.max(0, globalProducts[globalIndex].quantity - orderItem.quantity);
              globalProducts[globalIndex].status = globalProducts[globalIndex].quantity <= 0 ? 'Out of Stock' : 'Active';
            }
          });
          localStorage.setItem('products', JSON.stringify(globalProducts));
          console.log('ðŸ’¾ Also updated global products');
        }
      } catch (e) {
        console.log('âš ï¸ No global products to update');
      }
      
      // Refresh the display
      products = allProducts;
      renderProducts();
      
      console.log('âœ… Product stock reduced successfully');
      showToast('Product stock automatically updated', 'success');
    } else {
      console.log('âš ï¸ No stock was updated - no matching products found in seller storage');
      showToast('No products found to update stock', 'warn');
    }
    
  } catch (error) {
    console.error('âŒ Failed to reduce product stock:', error);
    showToast('Error updating product stock', 'error');
  }
}

/* ---------- Product CRUD ---------- */
/* *** IMPORTANT FIXED renderProducts (prevents duplicate DOM rows by batching seller lookups and atomically updating tbody) *** */

// simple render guard id
renderProducts._id = renderProducts._id || 0;

async function renderProducts() {
  // ðŸš¨ SAFETY CHECK: Fix any existing negative quantities
  products.forEach(p => {
    if (p.quantity < 0) {
      p.quantity = 0;
      p.status = 'Out of Stock';
      console.warn('Fixed negative quantity in product:', p.name);
    }
  });
  if (!prodTbody) return;

  // capture current render id
  const myId = ++renderProducts._id;

  const search = (productSearch?.value||'').toLowerCase();
  const filter = productStatusFilter?.value;
  const catFilter = productCategoryFilter?.value;
  const filtered = (products||[]).filter(p => {
    const matchesSearch = (p.name||'').toLowerCase().includes(search);
    const matchesStatus = filter ? p.status===filter : true;
    const matchesCat = catFilter ? (p.category === catFilter) : true;
    return matchesSearch && matchesStatus && matchesCat;
  });

  // if nothing to show, clear and quick-return
  if (!filtered.length) {
    prodTbody.innerHTML = '';
    const tr = document.createElement('tr');
    tr.innerHTML = `<td colspan="8" style="text-align:center;color:var(--muted)">No products</td>`;
    prodTbody.appendChild(tr);
    return;
  }

  // fetch all seller info in parallel (best-effort)
  const sellerPromises = filtered.map(p => {
    if (p && p.sellerId) return getSellerInfo(p.sellerId).catch(()=>null);
    return Promise.resolve(null);
  });

  let sellers = [];
  try {
    sellers = await Promise.all(sellerPromises);
  } catch (err) {
    // if something fails, continue with null sellers
    sellers = filtered.map(()=>null);
  }

  // if a newer render started while we were awaiting, abort this one
  if (myId !== renderProducts._id) return;

  // build fragment and update DOM atomically (prevents interleaving duplicates)
  const frag = document.createDocumentFragment();

  for (let i = 0; i < filtered.length; i++) {
    const p = filtered[i];
    const sellerData = sellers[i] || null;
    const sellerName = sellerData?.name || "Unknown Seller";
    const sellerAvatar = sellerData?.profilePictureUrl || "../../images/no profile pic.jpg";

    const tr = document.createElement('tr');

    const catName = p.category || 'Uncategorized';

    tr.innerHTML = `
      <td>
        <div style="display:flex;gap:10px;align-items:center">
          <img src="${p.img||'https://via.placeholder.com/80'}" 
              style="width:54px;height:54px;border-radius:6px;object-fit:cover;border:1px solid #e6eefc">
          <div>
            <div style="font-weight:700">${escapeHtml(p.name)}</div>
            <div class="small-muted">ID: ${escapeHtml(String(p.id||''))}</div>
            ${
              p.description 
                ? `<div class="small-muted" title="${escapeHtml(p.description)}"
                      style="max-width:200px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">
                    ${escapeHtml(p.description)}
                  </div>`
                : ''
            }
            <div class="small-muted" style="margin-top:6px;display:flex;align-items:center;gap:8px">
              <img src="${sellerAvatar}" style="width:20px;height:20px;border-radius:50%;vertical-align:middle;margin-right:5px">
              <span>${escapeHtml(sellerName)}</span>
            </div>
          </div>
        </div>
      </td>
      <td>GHC ${Number(p.price||0).toFixed(2)}</td>
      <td>${p.quantity||0}</td>
      <td>${p.condition||''}</td>
      <td>${escapeHtml(catName)}</td>
      <td><span class="status-badge ${p.status==='Active' ? 's-delivering' : 's-rejected'}">${escapeHtml(p.status||'')}</span></td>
      <td>${p.createdAt ? fmtDate(p.createdAt) : ''}</td>
      <td class="actions"></td>
    `;

    // actions (use addEventListener to avoid double-binding)
    const actionsTd = tr.querySelector('.actions');
    const editBtn = document.createElement('button'); editBtn.className='btn btn-edit'; editBtn.innerHTML = '<i class="fas fa-edit"></i> Edit';
    editBtn.addEventListener('click', (e) => { e.stopPropagation(); openProductEditor(p); });
    const delBtn = document.createElement('button'); delBtn.className='btn btn-delete'; delBtn.innerHTML = '<i class="fas fa-trash"></i> Delete';
    delBtn.addEventListener('click', (e) => { 
      e.stopPropagation();
      products = products.filter(x=>x.id!==p.id);
      saveWithCloudSync(productsKey(), products);
      localStorage._lastProductsJson = localStorage.getItem(productsKey()) || '[]';
      renderProducts();
      showToast('Product deleted','success');
    });
    actionsTd.appendChild(editBtn); actionsTd.appendChild(delBtn);

    frag.appendChild(tr);
  }

  // final check - if a new render started meanwhile, abort applying this fragment
  if (myId !== renderProducts._id) return;

  // replace tbody content atomically
  prodTbody.innerHTML = '';
  prodTbody.appendChild(frag);
}

function openProductEditor(p=null){
  productModal.style.display='flex';
  populateCategorySelects();

  if (p) {
    productModalTitle.textContent='Edit product';
    pName.value = p.name; pPrice.value = p.price; pQuantity.value = p.quantity;
    pCondition.value = p.condition; pStatus.value = p.status; pPreview.src = p.img||''; pPreview.style.display = p.img ? 'block' : 'none';
    pCategory.value = p.category || ''; pDescription.value = p.description || ''; 
    productModal.dataset.editId = p.id;
  } else {
    productModalTitle.textContent='Add product';
    delete productModal.dataset.editId;
    pName.value=''; pPrice.value=''; pQuantity.value=''; pCondition.value='New'; pStatus.value='Active'; pPreview.style.display='none'; pImage.value=''; pCategory.value=''; pDescription.value=''; 
  }
}
openAdd && openAdd.addEventListener('click', ()=> openProductEditor());
pCancel && pCancel.addEventListener('click', ()=> productModal.style.display='none');
// LONG-TERM SOLUTION: Smart auto-compression
// ðŸ–¼ï¸ FIXED IMAGE UPLOAD HANDLER
// ====== IMAGE VALIDATION & COMPRESSION ======
// Add this function to validate images before accepting them
function validateImage(file) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const url = URL.createObjectURL(file);
    
    // Set timeout to handle unresponsive images
    const timeout = setTimeout(() => {
      URL.revokeObjectURL(url);
      reject(new Error('Image took too long to load - may be corrupted'));
    }, 10000); // 10 second timeout
    
    img.onload = () => {
      clearTimeout(timeout);
      URL.revokeObjectURL(url);
      // Check if image loaded properly and has reasonable dimensions
      if (img.width > 10 && img.height > 10 && img.width < 10000 && img.height < 10000) {
        resolve({
          valid: true,
          width: img.width,
          height: img.height
        });
      } else {
        reject(new Error(`Image appears corrupted or has invalid dimensions (${img.width}x${img.height}px)`));
      }
    };
    
    img.onerror = () => {
      clearTimeout(timeout);
      URL.revokeObjectURL(url);
      reject(new Error('Failed to load image - file may be corrupted or unsupported'));
    };
    
    img.src = url;
  });
}

// ðŸ–¼ï¸ ENHANCED IMAGE UPLOAD HANDLER WITH VALIDATION
// âœ… REPLACE THE ENTIRE UPLOAD HANDLER WITH THIS:
pImage && pImage.addEventListener('change', async e => {
  const file = e.target.files[0];
  
  if (!file) {
    pPreview.style.display = 'none';
    return;
  }

  // ðŸŽ¯ STRICTER FILE SIZE CHECK
  const MAX_FILE_SIZE = 2 * 1024 * 1024; // 2MB
  if (file.size > MAX_FILE_SIZE) {
    showToast('âŒ Image too large! Please select an image under 2MB.', 'error');
    pImage.value = '';
    return;
  }

  // ðŸŽ¯ VALIDATE FILE TYPE
  const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
  if (!validTypes.includes(file.type)) {
    showToast('âŒ Please select JPEG, PNG, or WebP images only', 'error');
    pImage.value = '';
    return;
  }

  // ðŸŽ¯ SHOW LOADING STATE
pPreview.style.display = 'block';

// PULSING LOADING (fades in/out):
pPreview.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120' viewBox='0 0 24 24'%3E%3Ccircle cx='12' cy='12' r='10' stroke='%232563eb' stroke-width='2' fill='none'%3E%3Canimate attributeName='r' from='8' to='10' dur='0.8s' repeatCount='indefinite'/%3E%3Canimate attributeName='opacity' from='0.5' to='1' dur='0.8s' repeatCount='indefinite'/%3E%3C/circle%3E%3C/svg%3E";

showToast('ðŸ” Optimizing image...', 'info');
  try {
    // ðŸŽ¯ VALIDATE IMAGE
    const validation = await validateImage(file);
    showToast(`âœ… Image validated (${validation.width}x${validation.height}px)`, 'success');
    
    // ðŸŽ¯ COMPRESS IMAGE
    const quality = getStorageQualityLevel(file.size);
    showToast(`ðŸ”„ Compressing to ${quality * 100}% quality...`, 'info');
    
    const compressedBlob = await compressImageSmart(file, quality);
    
    // ðŸŽ¯ TRY TO UPLOAD TO CLOUD
    let cloudUrl = null;
    let useLocalFallback = false;
    
    try {
      showToast('ðŸ“¤ Uploading to cloud...', 'info');
      cloudUrl = await uploadToCloudinary(compressedBlob, file.name);
    } catch (uploadError) {
      console.warn('Cloud upload failed:', uploadError);
      
      // Ask user what to do
      const userChoice = confirm(
        `Cloud upload failed: ${uploadError.message}\n\n` +
        `Click OK to save locally (only this device sees image)\n` +
        `Click Cancel to try cloud upload again`
      );
      
      if (userChoice) {
        // User clicked OK = use local storage
        useLocalFallback = true;
        showToast('Using local storage (no cloud sync)', 'warn');
      } else {
        // User clicked Cancel = retry cloud
        throw uploadError; // This will show error toast below
      }
    }

    // ðŸŽ¯ SHOW THE IMAGE (cloud or local)
    if (cloudUrl && !useLocalFallback) {
      // Cloud upload worked!
      pPreview.src = cloudUrl;
      pImage.dataset.cloudUrl = cloudUrl;
      showToast('âœ… Image uploaded to cloud!', 'success');
    } else {
      // Using local storage (base64)
      const reader = new FileReader();
      reader.onload = ev => {
        pPreview.src = ev.target.result;
        const savings = ((file.size - compressedBlob.size) / file.size * 100).toFixed(1);
        showToast(`âœ… Saved locally (${savings}% smaller)`, 'warn');
      };
      reader.onerror = () => {
        throw new Error('Failed to process image');
      };
      reader.readAsDataURL(compressedBlob);
    }

  } catch (error) {
    console.error('Image processing failed:', error);
    pPreview.style.display = 'none';
    pImage.value = '';
    showToast(`âŒ ${error.message}. Please try a smaller or different image.`, 'error');
  }
});

// âœ… FIXED PRODUCT SAVE HANDLER
// âœ… REPLACE THE ENTIRE pSave CLICK HANDLER WITH THIS:
pSave && pSave.addEventListener('click', async ()=> {
  // ============================================
  // ðŸŽ¯ STORAGE PROTECTION
  // ============================================
  const currentProducts = JSON.parse(localStorage.getItem(productsKey()) || '[]');
  if (currentProducts.length >= 100) {
    showToast('âŒ Storage limit reached! Maximum 100 products allowed. Please delete some old products.', 'error');
    return;
  }
  
  const hasImage = pPreview.style.display !== 'none' && 
                   pPreview.src && 
                   !pPreview.src.includes('svg+xml');
  
  if (hasImage && pPreview.src.length > 500000) {
    showToast('âŒ Image too large for storage! Please use a smaller image or compress it more.', 'error');
    return;
  }
  
  // ============================================
  // ðŸŽ¯ ENHANCED VALIDATION
  // ============================================
  if (!hasImage) {
    alert("âŒ Please add a product image before saving!");
    pImage.focus();
    return;
  }

  const name = pName.value.trim();
  const price = Number(pPrice.value);
  const qty = Number(pQuantity.value);
  
  // ðŸš¨ STRICT QUANTITY VALIDATION
  if (qty < 0) {
    showToast('âŒ Quantity cannot be negative! Please enter 0 or higher.', 'error');
    pQuantity.focus();
    pQuantity.select();
    return;
  }
  
  // ðŸš¨ ENSURE QUANTITY IS A WHOLE NUMBER
  if (!Number.isInteger(qty)) {
    showToast('âŒ Quantity must be a whole number! Please remove decimals.', 'error');
    pQuantity.focus();
    pQuantity.select();
    return;
  }
  
  // ðŸš¨ PREVENT EXTREMELY LARGE QUANTITIES
  if (qty > 1000000) {
    showToast('âŒ Quantity is too large! Maximum is 1,000,000.', 'error');
    pQuantity.focus();
    pQuantity.select();
    return;
  }
  
  if (price < 0) { 
    showToast('âŒ Price must be zero or more!', 'error'); 
    pPrice.focus();
    pPrice.select();
    return; 
  }
  
  if (!name || !price || isNaN(qty)) { 
    showToast('âŒ Please enter valid name, price, and quantity!', 'error'); 
    return; 
  }
  
  const img = pImage.dataset.cloudUrl || pPreview.src || '';
  const category = pCategory.value || '';
  const description = pDescription.value.trim();

  if (productModal.dataset.editId) {
    const id = String(productModal.dataset.editId);
    const idx = products.findIndex(x => String(x.id) === String(id));
    if (idx > -1) {
      const status = qty <= 0 ? 'Out of Stock' : pStatus.value;
      const existingSellerId = products[idx].sellerId || auth.currentUser?.uid || null;
      products[idx] = {
        ...products[idx], 
        name, price, quantity: qty, condition: pCondition.value, status, img, 
        category, description, updatedAt: nowISO(), sellerId: existingSellerId
      };
      showToast('âœ… Product updated successfully!', 'success');
    }
  } else {
    const id = `${Date.now()}_${Math.random().toString(36).slice(2)}_${auth.currentUser?.uid || 'anon'}`;
    const status = qty <= 0 ? 'Out of Stock' : pStatus.value;
    products.push({ 
      id, name, price, quantity: qty, condition: pCondition.value, status, img, 
      createdAt: nowISO(), category, description, sellerId: auth.currentUser?.uid || null 
    });
    showToast('âœ… Product added successfully!', 'success');
  }
  
  await saveWithCloudSync(productsKey(), products);
  localStorage._lastProductsJson = localStorage.getItem(productsKey()) || '[]';
  productModal.style.display='none'; 
  renderProducts(); 
  renderAnalytics();
});

// Smart quality-based compression
// âœ… REPLACE WITH THIS STORAGE-FOCUSED FUNCTION:
function getStorageQualityLevel(fileSize) {
  // ðŸŽ¯ MUCH MORE AGGRESSIVE COMPRESSION FOR STORAGE
  if (fileSize > 3 * 1024 * 1024) return 0.5;    // 50% for very large files
  if (fileSize > 1.5 * 1024 * 1024) return 0.6;  // 60% for large files
  if (fileSize > 0.5 * 1024 * 1024) return 0.7;  // 70% for medium files
  return 0.8; // 80% for small files
}

// Advanced compression with size limits
// âœ… REPLACE WITH THIS OPTIMIZED FUNCTION:
async function compressImageSmart(file, quality = 0.7) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    img.onload = () => {
      // ðŸŽ¯ MUCH SMALLER DIMENSIONS FOR STORAGE
      let { width, height } = img;
      
      // Force maximum dimensions for storage
      const MAX_STORAGE_WIDTH = 600;
      const MAX_STORAGE_HEIGHT = 600;
      
      if (width > MAX_STORAGE_WIDTH || height > MAX_STORAGE_HEIGHT) {
        const ratio = Math.min(MAX_STORAGE_WIDTH / width, MAX_STORAGE_HEIGHT / height);
        width = Math.floor(width * ratio);
        height = Math.floor(height * ratio);
      }
      
      canvas.width = width;
      canvas.height = height;
      
      // Good enough quality for storage
      ctx.imageSmoothingQuality = 'medium';
      ctx.drawImage(img, 0, 0, width, height);
      
      // ðŸŽ¯ LOWER QUALITY FOR STORAGE
      canvas.toBlob((blob) => {
        if (blob) {
          console.log(`ðŸ“¦ STORAGE OPTIMIZED: ${formatBytes(file.size)} â†’ ${formatBytes(blob.size)} (${quality * 100}% quality, ${width}x${height})`);
          
          // ðŸš¨ REJECT IF STILL TOO LARGE
          if (blob.size > 300 * 1024) { // 300KB max
            reject(new Error('Image still too large after compression. Please try a smaller image.'));
            return;
          }
          
          resolve(blob);
        } else {
          reject(new Error('Compression failed'));
        }
      }, 'image/jpeg', quality); // Lower quality for storage
    };
    
    img.onerror = () => reject(new Error('Failed to load image'));
    img.src = URL.createObjectURL(file);
  });
}

// Helper function to format file sizes
function formatBytes(bytes, decimals = 2) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + ' ' + sizes[i];
}

/* ---------- Orders helpers ---------- */
/* 4-digit delivery code generator (created at order creation if missing) */
function assignDeliveryCode(order) {
  if (!order.deliveryCode) order.deliveryCode = Math.floor(1000 + Math.random()*9000).toString(); // 4-digit
  return order;
}

function ensureAppearedAt(order) {
  if (!order.appearedAt) order.appearedAt = nowISO();
  return order;
}

function orderThumbnail(o) {
  if (Array.isArray(o.items) && o.items.length) {
    return o.items[0].image || o.items[0].img || o.items[0].thumbnail || null;
  }
  if (o.product) {
    const prod = products.find(p => String(p.id) === String(o.productId) || p.name === o.product);
    if (prod && prod.img) return prod.img;
  }
  return null;
}

/* ---------- History helper ---------- */
function pushOrderHistory(order, actorId, actorType, action, note) {
  order.history = order.history || [];
  order.history.push({ actorId: actorId || null, actorType: actorType || 'system', action, note: note || null, timestamp: nowISO() });
}

/* ---------- Delivery request / bidding API (seller-side) ---------- */

/**
 * askForDelivery(orderId, windowSeconds = 300)
 * Starts a timed bid window for couriers to request to deliver.
 */
/**
 * askForDelivery(orderId, windowSeconds = 300)
 * Posts delivery request to public area where all delivery guys can see and bid
 */
/**
 * askForDelivery(orderId, windowSeconds = 300)
 * Posts delivery request to public area where all delivery guys can see and bid
 */
/**
 * Enhanced Ask for Delivery function with better validation and user experience
 */
function askForDelivery(orderId, windowSeconds = 300) {
  try {
    console.log('ðŸ”„ askForDelivery called for order:', orderId);
    
    // Load current orders
    orders = JSON.parse(localStorage.getItem(ordersKey()) || '[]') || [];
    const orderIndex = orders.findIndex(o => 
      String(o.id) === String(orderId) || String(o.orderId) === String(orderId)
    );
    
    if (orderIndex === -1) {
      showToast('Order not found in your orders', 'error');
      return;
    }

    const order = normalizeOrderFields(orders[orderIndex]);

    // ðŸ†• PREVENT DELIVERY REQUESTS FOR PICKUP ORDERS
    if (order.deliveryType === 'pickup') {
      showToast('Cannot request delivery for pickup orders', 'error');
      return;
    }
    
    // ðŸ”¥ VALIDATION: Check if order can be delivered
    if (order.status === 'Delivered' || order.status === 'Rejected') {
      showToast(`Cannot request delivery for ${order.status.toLowerCase()} orders`, 'error');
      return;
    }

    // ðŸ”¥ VALIDATION: Check if there's already an active delivery request
    const publicRequests = getPublicDeliveryRequests();
    const existingRequest = publicRequests.find(req => 
      req.orderId === order.id || req.orderId === order.orderId
    );
    
    if (existingRequest) {
      if (existingRequest.status === 'open') {
        showToast('Delivery request already active for this order', 'warn');
        // Show the existing request details
        showBiddersModal(order);
        return;
      } else if (existingRequest.status === 'assigned') {
        showToast('This order already has a courier assigned', 'warn');
        return;
      }
    }

    // ðŸ”¥ VALIDATION: Check if order is assigned to someone
    if (order.assignedTo || order.assignedDeliveryId) {
      showToast('This order is already assigned to a courier', 'warn');
      return;
    }

    // ðŸ”¥ VALIDATION: Check if seller is self-delivering
    if (order.ownerIsDelivering) {
      const proceed = confirm('You marked this for self-delivery. Do you want to cancel self-delivery and post to public bidding?');
      if (!proceed) return;
      order.ownerIsDelivering = false;
    }

    // Extract customer information
    const buyerObj = (order.buyer && typeof order.buyer === 'object') ? order.buyer : null;
    const customerInfo = {
      name: buyerObj?.name || order.buyerName || order.buyer || 'Unknown Customer',
      phone: buyerObj?.phone || order.phone || '',
      email: buyerObj?.email || order.email || '',
      room: buyerObj?.room || buyerObj?.roomNumber || order.room || '',
      index: buyerObj?.index || order.index || '',
      program: buyerObj?.program || '',
      profilePictureUrl: buyerObj?.profilePictureUrl || ''
    };

    // Validate essential customer info
    if (!customerInfo.name || customerInfo.name === 'Unknown Customer') {
      showToast('Customer information is incomplete', 'error');
      return;
    }

    // Create enhanced delivery request object
    const deliveryRequest = {
      id: `dr_${Date.now()}_${Math.random().toString(36).slice(2)}`,
      orderId: order.id || order.orderId,
      sellerId: auth.currentUser?.uid || (sessionStorage.getItem('uid') || null),
      sellerName: '', // Will be fetched async
      items: order.items || [{ 
        name: order.product || 'Unknown Product', 
        quantity: order.quantity || 1, 
        price: order.price || 0 
      }],
      customer: customerInfo,
      deliveryLocation: order.location || order.address || 'Marketplace Location',
      deliveryFee: order.delivery || order.deliveryFee || 0,
      totalOrderValue: order.total || 0,
      status: 'open',
      createdAt: nowISO(),
      updatedAt: nowISO(),
      bids: [],
      requestActive: true,
      // Additional metadata for better filtering
      urgency: 'standard', // Could be 'urgent', 'standard', 'flexible'
      estimatedPreparationTime: 15, // minutes
      specialInstructions: order.instructions || ''
    };

    // Show loading state
    const originalButton = document.querySelector(`[data-order-id="${orderId}"] .btn-edit`);
    if (originalButton) {
      originalButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Posting...';
      originalButton.disabled = true;
    }

    // Async fetch seller info for better display
    (async () => {
      try {
        const sellerInfo = await getSellerInfo(auth.currentUser?.uid);
        if (sellerInfo && sellerInfo.name) {
          deliveryRequest.sellerName = sellerInfo.name;
          deliveryRequest.sellerRating = sellerInfo.rating || 4.5; // Default rating
          
          // Update the public request with seller info
          const updatedRequests = getPublicDeliveryRequests();
          const requestIdx = updatedRequests.findIndex(req => req.id === deliveryRequest.id);
          if (requestIdx !== -1) {
            updatedRequests[requestIdx] = { ...updatedRequests[requestIdx], ...deliveryRequest };
            savePublicDeliveryRequests(updatedRequests);
          }
        }
      } catch (e) { 
        console.warn('Could not fetch seller info:', e);
      }
    })();

    // Add to public delivery requests
    const currentPublicRequests = getPublicDeliveryRequests();
    currentPublicRequests.push(deliveryRequest);
    savePublicDeliveryRequests(currentPublicRequests);

    // Update the original order
    order.requestActive = true;
    order.deliveryRequestId = deliveryRequest.id;
    order.deliveryRequestPostedAt = nowISO();
    order.ownerIsDelivering = false; // Ensure self-delivery is off

    pushOrderHistory(
      order, 
      auth.currentUser?.uid || null, 
      'seller', 
      'asked_for_delivery', 
      `Delivery request posted to public bidding area. Request ID: ${deliveryRequest.id}`
    );

    // Save updated order
    orders[orderIndex] = order;
    saveWithCloudSync(ordersKey(), orders);
    localStorage._lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';

    // Restore button state and show success
    setTimeout(() => {
      renderOrders();
      showToast('ðŸŽ‰ Delivery request posted! Couriers can now bid on your order', 'success');
      
      // Optional: Auto-open the bidders modal after a short delay
      setTimeout(() => {
        showBiddersModal(order);
      }, 1000);
    }, 500);

    console.info('âœ… askForDelivery completed:', {
      orderId: order.id,
      requestId: deliveryRequest.id,
      customer: customerInfo.name,
      deliveryFee: deliveryRequest.deliveryFee
    });

  } catch (error) {
    console.error('âŒ askForDelivery failed:', error);
    showToast('Failed to post delivery request. Please try again.', 'error');
    
    // Restore button state on error
    renderOrders();
  }
}

/**
 * cancelDeliveryRequest(orderId)
 * Seller cancels request and opts to self-deliver. This makes the order private (seller will deliver).
 */
/**
 * cancelDeliveryRequest(orderId)
 * Seller cancels the active delivery request â€” returns the order to the "no request" state
 * so the UI will show the "Ask for Delivery" button again.
 */
/**
 * cancelDeliveryRequest(orderId)
 * Seller cancels the active delivery request â€” clears any bidders so the request is fully reset.
 */
/**
 * Enhanced Cancel Delivery Request function
 */
function cancelDeliveryRequest(orderId) {
  try {
    console.log('ðŸ”„ cancelDeliveryRequest called for order:', orderId);
    
    if (!confirm('Are you sure you want to cancel this delivery request? This will remove it from the public bidding area and notify any bidders.')) {
      return;
    }

    orders = JSON.parse(localStorage.getItem(ordersKey()) || '[]') || [];
    const orderIndex = orders.findIndex(o => 
      String(o.id) === String(orderId) || String(o.orderId) === String(orderId)
    );
    
    if (orderIndex === -1) {
      showToast('Order not found', 'error');
      return;
    }

    const order = normalizeOrderFields(orders[orderIndex]);
    
    // Remove from public delivery requests
    const publicRequests = getPublicDeliveryRequests();
    const deliveryRequest = publicRequests.find(req => 
      req.id === order.deliveryRequestId || req.orderId === orderId
    );
    
    const updatedRequests = publicRequests.filter(req => 
      req.id !== order.deliveryRequestId && req.orderId !== orderId
    );
    
    savePublicDeliveryRequests(updatedRequests);

    // Notify bidders (in a real app, you'd send push notifications)
    const bidderCount = deliveryRequest ? (deliveryRequest.bids || []).length : 0;
    
    // Reset order delivery fields
    order.requestActive = false;
    order.deliveryRequestExpiry = null;
    order.ownerIsDelivering = false;
    order.deliveryRequestId = null;
    order.bidders = [];
    order.bids = [];

    pushOrderHistory(
      order, 
      auth.currentUser?.uid || null, 
      'seller', 
      'cancelled_delivery_request', 
      `Removed from public bidding area. ${bidderCount} bidder(s) were notified.`
    );

    // Save updated order
    orders[orderIndex] = order;
    saveWithCloudSync(ordersKey(), orders);
    localStorage._lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';

    // Force refresh and show confirmation
    window.dispatchEvent(new Event('publicDeliveryRequestsUpdated'));
    renderOrders();
    
    if (bidderCount > 0) {
      showToast(`Delivery request cancelled. ${bidderCount} bidder(s) were removed.`, 'success');
    } else {
      showToast('Delivery request cancelled successfully', 'success');
    }

    console.info('âœ… cancelDeliveryRequest completed:', {
      orderId: order.id,
      bidderCount: bidderCount
    });

  } catch (error) {
    console.error('âŒ cancelDeliveryRequest failed:', error);
    showToast('Failed to cancel delivery request', 'error');
  }
}

// Listen for public delivery request updates
window.addEventListener('publicDeliveryRequestsUpdated', () => {
  if (typeof refreshOrdersFromLocal === 'function') {
    refreshOrdersFromLocal();
  }
  if (typeof renderOrders === 'function') {
    renderOrders();
  }
});

/**
 * addBid(orderId, courierObj)
 * courierObj: { id, name, profilePictureUrl? }
 */

function addBid(orderId, courierObj) {
  orders = JSON.parse(localStorage.getItem(ordersKey())||'[]')||[];
  const idx = orders.findIndex(o => String(o.id) === String(orderId) || String(o.orderId) === String(orderId));
  if (idx === -1) return false;
  const order = normalizeOrderFields(orders[idx]);

  // only allow bids when seller has an open request and there is no assignment / seller-self-delivering
  if (!order.requestActive || order.assignedTo || order.ownerIsDelivering) {
    return false;
  }

  order.bidders = order.bidders || [];
  if (!order.bidders.find(b => String(b.id) === String(courierObj.id))) {
    order.bidders.push({
      id: courierObj.id,
      name: courierObj.name || 'Courier',
      profilePictureUrl: courierObj.profilePictureUrl || '',
      requestedAt: nowISO()
    });
    pushOrderHistory(order, courierObj.id, 'courier', 'bid', `Courier ${courierObj.name || courierObj.id} requested to deliver`);
    orders[idx] = order;
    saveWithCloudSync(ordersKey(), orders);
    localStorage._lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';
    // notify UI
    renderOrders();
    return true;
  }
  return false;
}

(() => {
  const orders = JSON.parse(localStorage.getItem(ordersKey()) || '[]');
  if (!Array.isArray(orders)) return console.log('no orders array found');
  let changed = false;
  orders.forEach(o => {
    if (o && Object.prototype.hasOwnProperty.call(o, 'deliveryRequestExpiry')) {
      delete o.deliveryRequestExpiry;
      changed = true;
    }
  });
  if (changed) {
    saveWithCloudSync(ordersKey(), orders);
    localStorage._lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';
    window.dispatchEvent(new Event('localOrdersUpdated'));
    console.log('Removed deliveryRequestExpiry from stored orders');
  } else {
    console.log('No deliveryRequestExpiry fields found');
  }
})();

/**
 * removeBid(orderId, courierId)
 */
function removeBid(orderId, courierId) {
  orders = JSON.parse(localStorage.getItem(ordersKey())||'[]')||[];
  const idx = orders.findIndex(o => String(o.id) === String(orderId) || String(o.orderId) === String(orderId));
  if (idx === -1) return false;
  const order = normalizeOrderFields(orders[idx]);
  const prevLen = order.bidders.length || 0;
  order.bidders = (order.bidders || []).filter(b => String(b.id) !== String(courierId));
  if ((order.bidders || []).length !== prevLen) {
    pushOrderHistory(order, courierId, 'courier', 'cancel_bid', 'Courier cancelled bid');
    orders[idx] = order;
    saveWithCloudSync(ordersKey(), orders);
    localStorage._lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';
    renderOrders();
    return true;
  }
  return false;
}

// safe number helper (if not already in file)
function _safeNum(v){ const n = Number(v); return Number.isFinite(n) ? n : 0; }

/**
 * assignCourier(orderId, courierId, courierName)
 * Seller action â€” assigns courier AND locks bid/earnings + computes seller profit.
 * Paste this to replace the existing assignCourier function in testsell.html
 */
/**
 * assignCourier - Enhanced to immediately lock assignment and sync globally
 */
function assignCourier(orderId, courierId, courierName) {
  console.log('ðŸ”„ assignCourier called:', { orderId, courierId, courierName });
  
  // ðŸ”¥ CRITICAL FIX: Get public delivery requests FIRST before anything else
  const publicRequests = getPublicDeliveryRequests();
  console.log('ðŸ” Public requests BEFORE assignment:', publicRequests);
  
  // Find the delivery request for this order
  const deliveryRequest = publicRequests.find(req => 
    String(req.orderId) === String(orderId) || String(req.id) === String(orderId)
  );
  
  console.log('ðŸ’° Delivery request found:', deliveryRequest);
  
  let chosenBid = null;
  if (deliveryRequest && deliveryRequest.bids) {
    chosenBid = deliveryRequest.bids.find(b => String(b.bidderId) === String(courierId));
    console.log('ðŸŽ¯ Chosen bid data:', chosenBid);
  }

  // load orders, find the right order
  orders = JSON.parse(localStorage.getItem(ordersKey()) || '[]') || [];
  const idx = orders.findIndex(o => String(o.id) === String(orderId) || String(o.orderId) === String(orderId));
  if (idx === -1) return showToast('Order not found','error');

  // normalize object
  const order = normalizeOrderFields(orders[idx]);
  console.log('ðŸ“¦ Order before assignment:', order);

  // mark assignment basics
  order.assignedTo = String(courierId);
  order.assignedDeliveryId = String(courierId);
  order.assignedAt = nowISO();
  order.requestActive = false;
  order.deliveryRequestExpiry = null;
  order.ownerIsDelivering = false;
  // ðŸŽ¯ KEEP current status, don't change to "Assigned"
// Just add delivery info WITHOUT changing status
// order.status = 'Assigned';  // DELETE THIS
// order.progressStep = 3;     // DELETE THIS

// Instead, keep whatever status it already has
if (!order.status) {
  order.status = 'Processing';  // Default if no status
}
// progressStep stays whatever it was
  order.deliveryPerson = courierName || String(courierId);

  // ðŸ”¥ CRITICAL FIX: Store the bid amount and ETA from the delivery request
  if (chosenBid) {
    console.log('ðŸ’¾ Storing bid data from delivery request:', {
      amount: chosenBid.amount,
      eta: chosenBid.eta
    });
    
    order.assignedBidAmount = Number(chosenBid.amount || 0);
    order.courierEarnings = Number(chosenBid.amount || 0);
    order.assignedBidderId = String(courierId);
    
    if (chosenBid.eta) {
      const etaNum = Number(chosenBid.eta);
      if (!Number.isNaN(etaNum) && etaNum > 0) {
        order.assignedBidEta = etaNum;
      } else {
        order.assignedBidEta = chosenBid.eta;
      }
    }
    
    order.bidAcceptedAt = nowISO();
  } else {
    console.warn('âŒ No bid found in delivery request for courier:', courierId);
    // Fallback: try to find in order.bids or order.bidders
    if (Array.isArray(order.bids) && order.bids.length) {
      const fallbackBid = order.bids.find(b => String(b.bidderId) === String(courierId));
      if (fallbackBid) {
        console.log('ðŸ”„ Using fallback bid data from order.bids:', fallbackBid);
        order.assignedBidAmount = Number(fallbackBid.amount || 0);
        order.courierEarnings = Number(fallbackBid.amount || 0);
        order.assignedBidderId = String(courierId);
        if (fallbackBid.eta) order.assignedBidEta = fallbackBid.eta;
      }
    } else if (Array.isArray(order.bidders) && order.bidders.length) {
      const fallbackBidder = order.bidders.find(b => String(b.id) === String(courierId));
      if (fallbackBidder) {
        console.log('ðŸ”„ Using fallback bid data from order.bidders:', fallbackBidder);
        order.assignedBidAmount = Number(fallbackBidder.amount || fallbackBidder.bidAmount || 0);
        order.courierEarnings = Number(fallbackBidder.amount || fallbackBidder.bidAmount || 0);
        order.assignedBidderId = String(courierId);
        if (fallbackBidder.eta) order.assignedBidEta = fallbackBidder.eta;
      }
    }
  }

  console.log('âœ… Order after storing bid data:', {
    assignedBidAmount: order.assignedBidAmount,
    assignedBidEta: order.assignedBidEta,
    courierEarnings: order.courierEarnings
  });

  // Compute seller leftover/profit
  const deliveryFee = _safeNum(order.deliveryFee || order.delivery || order.fee || 0);
  if (deliveryFee > 0 && order.assignedBidAmount) {
    const profit = deliveryFee - order.assignedBidAmount;
    order.deliveryProfit = Number(Math.max(0, profit).toFixed(2));
    order.sellerEarnings = Number(order.sellerEarnings || 0) + order.deliveryProfit;
  } else {
    order.deliveryProfit = Number(order.deliveryProfit || 0);
  }

  // history entry
  pushOrderHistory(order, auth?.currentUser?.uid || null, 'seller', 'assigned_courier',
    `Assigned courier ${courierName || courierId} â€¢ Amount: GHC ${order.assignedBidAmount || 0} â€¢ ETA: ${order.assignedBidEta || 'N/A'} min`
  );

  // ðŸ”¥ CRITICAL FIX: Remove from public delivery requests ONLY AFTER we've extracted the data
  const updatedRequests = publicRequests.filter(req => 
    req.orderId !== orderId && req.id !== order.deliveryRequestId
  );
  savePublicDeliveryRequests(updatedRequests);
  console.log('ðŸ—‘ï¸ Removed from public requests');

  // Save to delivery guy's local storage
  try {
    const deliveryGuyOrdersKey = `orders__delivery__${courierId}`;
    const deliveryGuyOrders = JSON.parse(localStorage.getItem(deliveryGuyOrdersKey) || '[]') || [];
    
    const existingIdx = deliveryGuyOrders.findIndex(o => 
      String(o.id) === String(orderId) || String(o.orderId) === String(orderId)
    );
    
    if (existingIdx === -1) {
      deliveryGuyOrders.push(order);
    } else {
      deliveryGuyOrders[existingIdx] = order;
    }
    
    localStorage.setItem(deliveryGuyOrdersKey, JSON.stringify(deliveryGuyOrders));
    localStorage.setItem(`orders_ping__delivery__${courierId}`, String(Date.now()));
    console.log('ðŸ’¾ Saved to delivery guy storage');
  } catch (e) {
    console.warn('Failed to save to delivery guy storage:', e);
  }

  // ðŸ”¥ SYNC TO GLOBAL ORDERS
  const globalOrders = getGlobalOrders();
  const globalIdx = globalOrders.findIndex(globalOrder => 
    String(globalOrder.id) === String(orderId) || String(globalOrder.orderId) === String(orderId)
  );

  if (globalIdx !== -1) {
    globalOrders[globalIdx] = { ...globalOrders[globalIdx], ...order };
    saveGlobalOrders(globalOrders);
    console.log('ðŸŒ Synced to global orders');
  }

  // persist and notify UI
  orders[idx] = order;
  saveWithCloudSync(ordersKey(), orders);
  localStorage._lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';

  try { if (biddersModal) biddersModal.style.display = 'none'; } catch(e){}
  
  // Force refresh
  window.dispatchEvent(new Event('publicDeliveryRequestsUpdated'));
  window.dispatchEvent(new Event('localOrdersUpdated'));
  
  renderOrders();
  
  console.log('ðŸŽ‰ Assignment completed with data:', {
    bidAmount: order.assignedBidAmount,
    bidETA: order.assignedBidEta,
    courierEarnings: order.courierEarnings
  });
  
  showToast(`âœ… ${courierName || courierId} assigned! Amount: GHC ${order.assignedBidAmount || 0}, ETA: ${order.assignedBidEta || 'N/A'} min`, 'success');
}

/* ---------- Bidders modal builder (injected) ---------- */
let biddersModal = null;
function ensureBiddersModal() {
  if (biddersModal) return biddersModal;
  biddersModal = document.createElement('div');
  biddersModal.className = 'modal';
  biddersModal.style.display = 'none';
  biddersModal.innerHTML = `<div class="modal-card" role="dialog" aria-modal="true"><h3 id="biddersTitle">Bidders</h3><div id="biddersList" style="max-height:360px;overflow:auto;margin-top:8px"></div><div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px"><button id="closeBidders" class="btn">Close</button></div></div>`;
  document.body.appendChild(biddersModal);
  biddersModal.querySelector('#closeBidders').addEventListener('click', ()=> biddersModal.style.display='none');
  return biddersModal;
}

function sanitizeDomId(s) {
  return String(s||'').replace(/[^a-z0-9\-_]/gi, '-');
}

async function showBiddersModal(order) {
  ensureBiddersModal();
  
  // Read from public delivery requests instead of local orders
  const publicRequests = getPublicDeliveryRequests();
  const deliveryRequest = publicRequests.find(req => 
    req.orderId === order.id || req.orderId === order.orderId
  );
  
  const modal = biddersModal;
  const listEl = modal.querySelector('#biddersList');
  listEl.innerHTML = '';
  
  if (!deliveryRequest) {
    listEl.innerHTML = `<div class="small-muted">No active delivery request found for this order.</div>`;
    modal.style.display = 'flex';
    return;
  }

  const bids = deliveryRequest.bids || [];

  if (!bids.length) {
    listEl.innerHTML = `<div class="small-muted">No bidders yet.</div>`;
    modal.style.display = 'flex';
    return;
  }

  // Build bidder cards from public requests
  for (const bid of bids) {
    const bidId = String(bid.bidderId || '');
    const displayName = bid.bidderName || bidId || 'Courier';
    const avatar = bid.bidderAvatar || '../../images/no profile pic.jpg';
    const amountText = (typeof bid.amount !== 'undefined' && bid.amount !== null) ? `GHC ${Number(bid.amount).toFixed(2)}` : '';
    const etaText = bid.eta ? ` â€¢ ETA: ${escapeHtml(String(bid.eta))} min` : '';
    const placedText = bid.placedAt ? fmtDate(bid.placedAt) : '';

    const card = document.createElement('div');
    card.className = 'bid-card';
    card.style.cssText = 'display:flex;align-items:center;justify-content:space-between;padding:12px;border-bottom:1px solid #eee;gap:12px;';

    // Left section (avatar + info)
    const left = document.createElement('div');
    left.style.cssText = 'display:flex;align-items:center;gap:12px;flex:1;';
    left.innerHTML = `
      <img src="${escapeHtml(avatar)}" style="width:48px;height:48px;border-radius:8px;object-fit:cover" onerror="this.onerror=null;this.src='../../images/no profile pic.jpg'">
      <div style="min-width:0;flex:1;">
        <div style="font-weight:700">${escapeHtml(displayName)}</div>
        <div class="small-muted" style="font-size:12px">UID: ${escapeHtml(bidId)}</div>
        ${amountText || etaText ? `<div class="small-muted" style="margin-top:6px">${escapeHtml(amountText)}${escapeHtml(etaText)}</div>` : ''}
        ${bid.bidderPhone ? `<div class="small-muted" style="margin-top:4px">ðŸ“ž ${escapeHtml(bid.bidderPhone)}</div>` : ''}
        ${bid.bidderEmail ? `<div class="small-muted">âœ‰ï¸ ${escapeHtml(bid.bidderEmail)}</div>` : ''}
        ${bid.bidderIndex ? `<div class="small-muted">Index: ${escapeHtml(bid.bidderIndex)}</div>` : ''}
        ${bid.bidderProgram ? `<div class="small-muted">Program: ${escapeHtml(bid.bidderProgram)}</div>` : ''}
        ${bid.bidderRoom ? `<div class="small-muted">Room: ${escapeHtml(bid.bidderRoom)}</div>` : ''}
        <div class="small-muted" style="margin-top:4px">Placed: ${escapeHtml(placedText)}</div>
      </div>
    `;

    // Right section (buttons)
    const right = document.createElement('div');
    right.style.cssText = 'display:flex;align-items:center;gap:8px;flex-shrink:0;';

    const assignBtn = document.createElement('button');
    assignBtn.className = 'btn btn-accept';
    assignBtn.textContent = 'Assign';
    assignBtn.setAttribute('data-bid-id', bidId);
    assignBtn.setAttribute('data-order-id', String(order.id || order.orderId || ''));

    const removeBtn = document.createElement('button');
    removeBtn.className = 'btn btn-warn';
    removeBtn.textContent = 'Remove';
    removeBtn.setAttribute('data-bid-id', bidId);
    removeBtn.setAttribute('data-request-id', deliveryRequest.id);

    right.appendChild(assignBtn);
    right.appendChild(removeBtn);
    card.appendChild(left);
    card.appendChild(right);
    listEl.appendChild(card);

    // Event handlers
    assignBtn.addEventListener('click', async (e) => {
    e.stopPropagation();
    if (!confirm(`Assign ${displayName} to this order? This will immediately assign them and they can start delivery.`)) return;
  
    let friendlyName = displayName;
    try {
    const userProfile = await getSellerInfo(bidId);
    if (userProfile && userProfile.name) friendlyName = userProfile.name;
    } catch (err) { /* ignore */ }
  
    // ðŸ”¥ IMMEDIATELY ASSIGN AND UPDATE STATUS
    assignCourier(order.id || order.orderId, bidId, friendlyName);
  
    // ðŸ”¥ UPDATE ORDER STATUS TO "Assigned" so delivery guy can start immediately
    changeOrderStatus(order, 'Assigned');
  
    modal.style.display = 'none';
    showToast(`âœ… ${friendlyName} assigned and can start delivery now!`, 'success');
    });
    removeBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      if (!confirm(`Remove ${displayName}'s bid from this delivery request?`)) return;

      // Remove bid from public requests
      const updatedRequests = publicRequests.map(req => {
        if (req.id === deliveryRequest.id) {
          return {
            ...req,
            bids: req.bids.filter(b => String(b.bidderId) !== String(bidId))
          };
        }
        return req;
      });
      
      savePublicDeliveryRequests(updatedRequests);
      showToast('Bid removed from delivery request', 'success');
      showBiddersModal(order); // Refresh modal
    });
  }

  modal.style.display = 'flex';
}

/* ---------- Show Assigned Courier Details Modal ---------- */
/* ---------- Show Assigned Courier Details Modal ---------- */
async function showAssignedCourierDetails(order) {
  // Create or get the modal
  let assignedModal = document.getElementById('assignedCourierModal');
  if (!assignedModal) {
    assignedModal = document.createElement('div');
    assignedModal.id = 'assignedCourierModal';
    assignedModal.className = 'modal';
    assignedModal.innerHTML = `
      <div class="modal-card" role="dialog" aria-modal="true">
        <h3>Assigned Courier Details</h3>
        <div id="assignedCourierContent" style="max-height:400px;overflow:auto"></div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
          <button id="closeAssignedModal" class="btn btn-warn">Close</button>
        </div>
      </div>
    `;
    document.body.appendChild(assignedModal);
    
    // Close button handler
    assignedModal.querySelector('#closeAssignedModal').addEventListener('click', () => {
      assignedModal.style.display = 'none';
    });
  }

  const contentEl = assignedModal.querySelector('#assignedCourierContent');
  contentEl.innerHTML = '<div style="text-align:center;padding:20px"><i class="fas fa-spinner fa-spin"></i> Loading courier details...</div>';
  
  assignedModal.style.display = 'flex';

  try {
    // Get the assigned courier ID
    const assignedTo = order.assignedTo || order.assignedDeliveryId;
    
    if (!assignedTo) {
      contentEl.innerHTML = '<div style="text-align:center;color:var(--muted)">No courier assignment information found.</div>';
      return;
    }

    // Fetch courier details
    const courierProfile = await getSellerInfo(assignedTo);
    
    // ðŸ”¥ Calculate financial breakdown
    const deliveryFee = Number(order.deliveryFee || order.delivery || 0);
    const courierEarnings = Number(order.courierEarnings || order.assignedBidAmount || 0);
    const sellerProfit = Number(order.deliveryProfit || (deliveryFee - courierEarnings));
    const platformFee = 0; // You can add platform fees if needed
    
    // ðŸ”¥ Get timing information
    const promisedETA = order.assignedBidEta || 'Not specified';
    const assignedTime = order.assignedAt;
    const currentTime = new Date();
    const assignedDate = new Date(assignedTime);
    const timeSinceAssignment = Math.round((currentTime - assignedDate) / (1000 * 60)); // minutes
    
    if (!courierProfile) {
      contentEl.innerHTML = `
        <div style="text-align:center">
          <div style="color:var(--muted);margin-bottom:12px">Courier details not available</div>
          <div class="small-muted">Courier ID: ${escapeHtml(assignedTo)}</div>
          <div class="small-muted">Assigned at: ${fmtDate(order.assignedAt)}</div>
        </div>
      `;
      return;
    }

    // Display courier details with financial and timing info
    contentEl.innerHTML = `
      <div style="text-align:center;margin-bottom:20px">
        <img src="${courierProfile.profilePictureUrl || '../../images/no profile pic.jpg'}" 
             style="width:100px;height:100px;border-radius:50%;object-fit:cover;border:3px solid #10b981">
        <h3 style="margin:12px 0 4px 0">${escapeHtml(courierProfile.name || 'Unknown Courier')}</h3>
        <div class="small-muted">Courier ID: ${escapeHtml(assignedTo)}</div>
      </div>

      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:16px">
        <div style="text-align:center;padding:12px;background:var(--light-bg);border-radius:8px">
          <div class="small-muted">Phone</div>
          <div style="font-weight:600">${courierProfile.phone ? escapeHtml(courierProfile.phone) : 'Not provided'}</div>
        </div>
        <div style="text-align:center;padding:12px;background:var(--light-bg);border-radius:8px">
          <div class="small-muted">Email</div>
          <div style="font-weight:600">${courierProfile.email ? escapeHtml(courierProfile.email) : 'Not provided'}</div>
        </div>
      </div>

      <!-- ðŸ”¥ FINANCIAL BREAKDOWN SECTION -->
      <div style="margin-bottom:16px;padding:16px;background:#f8fafc;border-radius:8px;border:1px solid #e2e8f0">
        <strong style="display:block;margin-bottom:12px;color:#1e40af;">ðŸ’° Delivery Fee Breakdown</strong>
        
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:12px">
          <div style="text-align:center;padding:10px;background:white;border-radius:6px">
            <div class="small-muted" style="font-size:12px">Total Delivery Fee</div>
            <div style="font-weight:700;color:#1e40af;font-size:1.1rem">GHC ${deliveryFee.toFixed(2)}</div>
          </div>
          <div style="text-align:center;padding:10px;background:white;border-radius:6px">
            <div class="small-muted" style="font-size:12px">Courier's Share</div>
            <div style="font-weight:700;color:#10b981;font-size:1.1rem">GHC ${courierEarnings.toFixed(2)}</div>
          </div>
        </div>
        
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
          <div style="text-align:center;padding:10px;background:white;border-radius:6px">
            <div class="small-muted" style="font-size:12px">Your Profit</div>
            <div style="font-weight:700;color:#f59e0b;font-size:1.1rem">GHC ${sellerProfit.toFixed(2)}</div>
          </div>
          <div style="text-align:center;padding:10px;background:white;border-radius:6px">
            <div class="small-muted" style="font-size:12px">Platform Fee</div>
            <div style="font-weight:700;color:#64748b;font-size:1.1rem">GHC ${platformFee.toFixed(2)}</div>
          </div>
        </div>
        
        <div style="margin-top:12px;padding:10px;background:#dbeafe;border-radius:6px">
          <div class="small-muted" style="font-size:12px;color:#1e40af">Courier requested <strong>GHC ${courierEarnings.toFixed(2)}</strong> out of the GHC ${deliveryFee.toFixed(2)} delivery fee</div>
        </div>
      </div>

      <!-- ðŸ”¥ TIMING INFORMATION SECTION -->
      <div style="margin-bottom:16px;padding:16px;background:#fffbeb;border-radius:8px;border:1px solid #fcd34d">
        <strong style="display:block;margin-bottom:12px;color:#d97706;">â° Delivery Timing</strong>
        
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:12px">
          <div style="text-align:center;padding:10px;background:white;border-radius:6px">
            <div class="small-muted" style="font-size:12px">Promised ETA</div>
            <div style="font-weight:700;color:#d97706;font-size:1.1rem">
              ${typeof promisedETA === 'number' ? `${promisedETA} min` : escapeHtml(promisedETA)}
            </div>
            <div class="small-muted" style="font-size:10px">Estimated delivery time</div>
          </div>
          <div style="text-align:center;padding:10px;background:white;border-radius:6px">
            <div class="small-muted" style="font-size:12px">Time Since Assigned</div>
            <div style="font-weight:700;color:#dc2626;font-size:1.1rem">${timeSinceAssignment} min</div>
            <div class="small-muted" style="font-size:10px">Currently active</div>
          </div>
        </div>
        
        <div style="margin-top:8px">
          <div class="small-muted">Assigned at: ${fmtDate(assignedTime)}</div>
          ${typeof promisedETA === 'number' ? 
            `<div class="small-muted">Expected completion: ${fmtDate(new Date(assignedDate.getTime() + (promisedETA * 60000)))}</div>` : 
            ''
          }
        </div>
      </div>

      <div style="margin-bottom:16px">
        <strong>Contact Information:</strong>
        <div style="margin-top:8px">
          ${courierProfile.phone ? `<div class="small-muted">ðŸ“ž Phone: ${escapeHtml(courierProfile.phone)}</div>` : ''}
          ${courierProfile.email ? `<div class="small-muted">âœ‰ï¸ Email: ${escapeHtml(courierProfile.email)}</div>` : ''}
          ${courierProfile.index ? `<div class="small-muted">ðŸ†” Index: ${escapeHtml(courierProfile.index)}</div>` : ''}
          ${courierProfile.program ? `<div class="small-muted">ðŸŽ“ Program: ${escapeHtml(courierProfile.program)}</div>` : ''}
          ${courierProfile.room ? `<div class="small-muted">ðŸ  Room: ${escapeHtml(courierProfile.room)}</div>` : ''}
        </div>
      </div>

      <div style="background:#f0f9ff;padding:12px;border-radius:8px;border-left:4px solid #2563eb">
        <strong>Delivery Status:</strong>
        <div style="margin-top:4px">
          <span class="status-badge ${statusClass(order.status)}">${escapeHtml(order.status || 'Assigned')}</span>
          <div class="small-muted" style="margin-top:4px">
            ${order.status === 'Assigned' ? 'The courier has been assigned and can start delivery.' : 
              order.status === 'Delivering' ? 'The courier is currently delivering the order.' :
              order.status === 'At Door' ? 'The courier has arrived at the delivery location.' :
              'Delivery in progress.'}
          </div>
        </div>
      </div>

      <!-- ðŸ”¥ PERFORMANCE METRICS (if available) -->
      ${order.performance ? `
        <div style="margin-top:16px;padding:12px;background:#ecfdf5;border-radius:8px;border-left:4px solid #10b981">
          <strong style="color:#065f46;">ðŸ“Š Performance Metrics</strong>
          <div style="margin-top:8px">
            <div class="small-muted">On-time Performance: <strong>${(order.performance * 100).toFixed(0)}%</strong></div>
            ${order.actualDeliveryTime ? `<div class="small-muted">Actual Delivery Time: <strong>${order.actualDeliveryTime} min</strong></div>` : ''}
            ${order.onTime !== undefined ? `<div class="small-muted">On-time Status: <strong>${order.onTime ? 'âœ… On Time' : 'âŒ Late'}</strong></div>` : ''}
          </div>
        </div>
      ` : ''}
    `;

  } catch (error) {
    console.error('Error loading assigned courier details:', error);
    contentEl.innerHTML = '<div style="text-align:center;color:var(--danger)">Error loading courier details. Please try again.</div>';
  }
}

/* ---------- Order details HTML (unchanged but show bidders summary) ---------- */
// Replace your existing renderOrderDetailsHtml with this improved version
function renderOrderDetailsHtml(o){
  // build base (buyer/items/summary) like before
  const baseHtml = (function(){
    const buyerObj = (o.buyer && typeof o.buyer === 'object') ? o.buyer : null;
    const buyerName = escapeHtml(buyerObj?.name || o.buyerName || o.buyer || o.customer || 'Anonymous');
    const buyerPhone = escapeHtml(buyerObj?.phone || o.phone || '');
    const buyerEmail = escapeHtml(buyerObj?.email || o.email || '');
    const buyerRoom  = escapeHtml(buyerObj?.room || buyerObj?.roomNumber || buyerObj?.roomnumber || o.room || '');
    const buyerIndex = escapeHtml(buyerObj?.index || o.index || '');
    const buyerProgram = escapeHtml(buyerObj?.program || '');
    const buyerAvatar = buyerObj?.profilePictureUrl || '';

    const items = Array.isArray(o.items) ? o.items : (o.product ? [{name:o.product,price:o.price||0,quantity:o.quantity||1,image: orderThumbnail(o)}] : []);
    const itemsHtml = items.map(it => {
      const imgSrc = it.image || orderThumbnail(o) || 'https://via.placeholder.com/90';
      return `<div class="order-item" style="display:flex;gap:10px;align-items:center;margin-bottom:10px">
        <img class="item-thumb" src="${escapeHtml(imgSrc)}" alt="${escapeHtml(it.name || '')}" style="width:72px;height:72px;object-fit:cover;border-radius:6px">
        <div>
          <div style="font-weight:700">${escapeHtml(it.name || '')}</div>
          <div class="small-muted">Price: GHC ${(Number(it.price)||0).toFixed(2)} â€¢ Qty: ${it.quantity||1}</div>
        </div>
      </div>`;
    }).join('');

    const subtotal = o.subtotal || items.reduce((s,i)=> s + ((Number(i.price)||0) * (Number(i.quantity)||1)), 0);
    const deliveryFee = o.delivery || o.deliveryFee || 0;
    const courierEarnings = o.courierEarnings || o.assignedBidAmount || 0;
    const deliveryProfit = o.deliveryProfit || (deliveryFee - courierEarnings);
    const sellerRevenue = subtotal + deliveryProfit;
    const placed = o.appearedAt || o.date || '';

    const assignedPlaceholderId = `assigned-info-${sanitizeDomId(o.id||o.orderId)}`;

    return `<div class="order-details" style="display:flex;gap:12px;align-items:flex-start;justify-content:space-between">
      <div style="flex:1">
        <div style="font-weight:700">Items</div>
        <div class="order-items" style="margin-top:8px">${itemsHtml}</div>
      </div>
      <div style="width:320px">
        <div style="font-weight:700">Summary</div>
        <div class="small-muted">Placed: ${fmtDate(placed)}</div>
        <div class="small-muted">Subtotal: GHC ${Number(subtotal||0).toFixed(2)}</div>
        <div class="small-muted">Delivery Fee: GHC ${Number(deliveryFee||0).toFixed(2)}</div>
        ${courierEarnings > 0 ? `<div class="small-muted">Courier Earnings: GHC ${Number(courierEarnings||0).toFixed(2)}</div>` : ''}
        ${deliveryProfit > 0 ? `<div class="small-muted" style="color:var(--success);font-weight:600">Your Delivery Profit: GHC ${Number(deliveryProfit||0).toFixed(2)}</div>` : ''}
        <div style="margin-top:8px;font-weight:800;color:var(--success)">Your Revenue: GHC ${Number(sellerRevenue||0).toFixed(2)}</div>
        ${o.deliveryPerson?`<div class="small-muted">Courier: ${escapeHtml(o.deliveryPerson)}</div>`:''}
        <div id="${assignedPlaceholderId}" class="small-muted" style="margin-top:6px"></div>
        <div class="small-muted" style="margin-top:6px">Progress step: ${o.progressStep || getProgressStep(o.status)}</div>
        <hr style="margin:10px 0;border:none;border-top:1px solid #eee">
        <div style="font-weight:700">Buyer</div>
        ${buyerAvatar ? `<div style="margin-top:6px;margin-bottom:6px"><img src="${escapeHtml(buyerAvatar)}" alt="${buyerName}" style="width:64px;height:64px;border-radius:8px;object-fit:cover"></div>` : ''}
        <div class="small-muted" style="margin-top:6px">${buyerName}</div>
        ${buyerPhone?`<div class="small-muted">ðŸ“ž ${buyerPhone}</div>` : ''}
        ${buyerEmail?`<div class="small-muted">âœ‰ï¸ ${buyerEmail}</div>` : ''}
        ${buyerRoom?`<div class="small-muted">ðŸ  ${buyerRoom}</div>` : ''}
        ${buyerIndex?`<div class="small-muted">ðŸ†” ${buyerIndex}</div>` : ''}
        ${buyerProgram?`<div class="small-muted">ðŸŽ“ ${buyerProgram}</div>` : ''}
      </div>
    </div>`; 
  })();

  // Get bids from public delivery requests
const publicRequests = getPublicDeliveryRequests();
const deliveryRequest = publicRequests.find(req => 
  req.orderId === o.id || req.orderId === o.orderId
);

const bids = deliveryRequest ? (deliveryRequest.bids || []) : [];
const isAssigned = !!(o.assignedTo || o.assignedDeliveryId);

// ðŸ”¥ ONLY show bidders if NOT assigned
let biddersHtml = '';
if (!isAssigned && bids.length) {
  biddersHtml = `<div style="margin-top:16px;padding:16px;background:var(--light-bg);border-radius:8px;">
    <strong style="display:block;margin-bottom:12px;">Bidders (${bids.length})</strong>
    <div style="display:flex;flex-direction:column;gap:12px;">
      ${bids.map(bid => {
        const displayName = escapeHtml(bid.bidderName || bid.bidderId || 'Courier');
        const avatar = escapeHtml(bid.bidderAvatar || '../../images/no profile pic.jpg');
        const amountText = (typeof bid.amount !== 'undefined' && bid.amount !== null) ? `GHC ${Number(bid.amount).toFixed(2)}` : '';
        const etaText = bid.eta ? ` â€¢ ETA: ${escapeHtml(String(bid.eta))} min` : '';
        const placed = fmtDate(bid.placedAt || '');
        
        return `
          <div style="display:flex;align-items:center;gap:12px;padding:12px;background:white;border-radius:8px;border:1px solid #eee;">
            <img src="${avatar}" style="width:48px;height:48px;border-radius:6px;object-fit:cover">
            <div style="flex:1">
              <div style="font-weight:700">${displayName}</div>
              <div class="small-muted">UID: ${escapeHtml(bid.bidderId || '')}</div>
              ${amountText || etaText ? `<div class="small-muted" style="margin-top:4px">${escapeHtml(amountText)}${escapeHtml(etaText)}</div>` : ''}
              ${bid.bidderPhone ? `<div class="small-muted">ðŸ“ž ${escapeHtml(bid.bidderPhone)}</div>` : ''}
              ${bid.bidderEmail ? `<div class="small-muted">âœ‰ï¸ ${escapeHtml(bid.bidderEmail)}</div>` : ''}
              <div class="small-muted" style="margin-top:4px">Placed: ${escapeHtml(placed)}</div>
            </div>
            <div style="display:flex;gap:8px;flex-shrink:0;">
              <button class="btn btn-accept btn-sm" 
                      data-bid-id="${escapeHtml(bid.bidderId || '')}" 
                      data-order-id="${escapeHtml(o.id || o.orderId || '')}">
                Assign
              </button>
            </div>
          </div>
        `;
      }).join('')}
    </div>
  </div>`;
} else if (!isAssigned) {
  biddersHtml = `<div style="margin-top:16px;padding:12px;background:var(--light-bg);border-radius:8px;text-align:center;" class="small-muted">
    No bidders yet
  </div>`;
} else {
  // ðŸ”¥ Show assigned courier info instead of bidders
  const assignedTo = o.assignedTo || o.assignedDeliveryId;
  biddersHtml = `<div style="margin-top:16px;padding:16px;background:#f0f9ff;border-radius:8px;border-left:4px solid #10b981;">
    <strong style="display:block;margin-bottom:12px;color:#10b981;">âœ… Assigned to Courier</strong>
    <div style="display:flex;align-items:center;gap:12px;">
      <i class="fas fa-user-check" style="font-size:1.5rem;color:#10b981;"></i>
      <div>
        <div style="font-weight:700">${escapeHtml(o.deliveryPerson || assignedTo || 'Courier')}</div>
        <div class="small-muted">Courier ID: ${escapeHtml(assignedTo || 'Unknown')}</div>
        <div class="small-muted">Assigned: ${fmtDate(o.assignedAt)}</div>
        <button class="btn btn-accept btn-sm" style="margin-top:8px" onclick="showAssignedCourierDetails(${JSON.stringify(o).replace(/"/g, '&quot;')})">
          View Courier Details
        </button>
      </div>
    </div>
  </div>`;
}

  return biddersHtml + baseHtml;
}


/* ---------- Render Orders ---------- */
let lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';

// ðŸ”¥ ADD THIS FUNCTION - Syncs global order status to seller storage
function syncSellerOrdersFromGlobal() {
  try {
    const globalOrders = getGlobalOrders();
    const sellerOrdersKey = ordersKey();
    let sellerOrders = JSON.parse(localStorage.getItem(sellerOrdersKey) || '[]');
    
    let changed = false;
    
    // Update each seller order with latest status from global
    sellerOrders.forEach((sellerOrder, index) => {
      const globalOrder = globalOrders.find(g => 
        String(g.id) === String(sellerOrder.id) || 
        String(g.orderId) === String(sellerOrder.orderId)
      );
      
      if (globalOrder && sellerOrder.status !== globalOrder.status) {
        sellerOrders[index].status = globalOrder.status;
        sellerOrders[index].progressStep = globalOrder.progressStep;
        sellerOrders[index].deliveredAt = globalOrder.deliveredAt;
        sellerOrders[index].deliveryPerson = globalOrder.deliveryPerson;
        changed = true;
      }
    });
    
    if (changed) {
      localStorage.setItem(sellerOrdersKey, JSON.stringify(sellerOrders));
    }
  } catch (error) {
    console.log('Sync error:', error);
  }
}

function renderOrders(notifyNew = false){
  try {
    syncSellerOrdersFromGlobal();
    // read seller orders raw and normalize them (same as before)
    // ðŸ”¥ READ FROM GLOBAL ORDERS (the shared notebook)
    // ðŸŽ¯ STEP 1: Look only in YOUR orders box
    let orders = JSON.parse(localStorage.getItem(ordersKey()) || '[]');
      
    // ðŸŽ¯ STEP 2: Check the big board for updates  
    syncSellerOrdersFromGlobal();
      
    // ðŸŽ¯ STEP 3: Only keep orders with YOUR name
    const sellerUid = getUid();
    orders = orders.filter(order => 
      order.intendedSellerId === sellerUid || 
      order.sellerId === sellerUid
    );
    if (ordersTbody) ordersTbody.innerHTML = '';

    let changed = false;
    orders.forEach((o, idx) => {
      normalizeOrderFields(o);
      if (typeof o.progressStep === 'undefined') { o.progressStep = getProgressStep(o.status); changed = true; }
      if (!o.deliveryCode) { assignDeliveryCode(o); changed = true; }
      if (!o.appearedAt) { ensureAppearedAt(o); changed = true; }
      orders[idx] = o;
    });
    if (changed) saveWithCloudSync(ordersKey(), orders);

    // ensure final-state orders moved into completed before rendering
    const reconciled = reconcileSellerOrders();
    let sellerOrders = reconciled.active || [];

    const sTerm = (orderSearch?.value||'').toLowerCase();
    const fStatus = orderFilter?.value;

    // If no active seller orders, show empty state and stop
    if (!sellerOrders.length) {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td colspan="6" style="text-align:center;color:var(--muted)">No orders yet</td>`;
      ordersTbody && ordersTbody.appendChild(tr);
      updateOrdersBadge(0);
      renderAnalytics();
      lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';
      return;
    }

    // Build filtered list from reconciled active orders
    const list = sellerOrders.slice().reverse().filter(o => {
      const buyerObj = (o.buyer && typeof o.buyer === 'object') ? o.buyer : null;
      const buyerSearch = `${buyerObj?.name||o.buyerName||o.buyer||o.customer||''} ${buyerObj?.phone||o.phone||''} ${buyerObj?.email||o.email||''} ${buyerObj?.room||buyerObj?.roomNumber||buyerObj?.roomnumber||o.room||''}`;
      const combined = `${buyerSearch} ${JSON.stringify(o.items||o.product||'')}`;
      return (!sTerm || combined.toLowerCase().includes(sTerm) || String(o.id||'').includes(sTerm)) && (!fStatus || o.status===fStatus);
    });

    list.forEach(o => {
      if (typeof o.progressStep === 'undefined') o.progressStep = getProgressStep(o.status);
      if (!o.appearedAt) o.appearedAt = nowISO();

      const tr = document.createElement('tr');

      const thumbUrl = orderThumbnail(o) || 'https://via.placeholder.com/90';
      const itemsSummary = Array.isArray(o.items) ? o.items.map(i=>i.name).join(', ') : (o.product||'-');
      const qty = Array.isArray(o.items) ? o.items.reduce((s,i)=>s+(i.quantity||1),0) : (o.quantity||1);

      // buyer display fields (favor object)
      const buyerObj = (o.buyer && typeof o.buyer === 'object') ? o.buyer : null;
      const buyerNameDisplay = escapeHtml(buyerObj?.name || o.buyerName || o.buyer || o.customer || 'Anonymous');
      const buyerPhoneDisplay = escapeHtml(buyerObj?.phone || o.phone || '');
      const buyerRoomDisplay = escapeHtml(buyerObj?.room || buyerObj?.roomNumber || buyerObj?.roomnumber || o.room || '');
      const buyerAvatar = buyerObj?.profilePictureUrl || '';

      tr.innerHTML = `
        <td>
          ${escapeHtml(o.id || o.orderId || '')}
          <div class="small-muted">${fmtDate(o.appearedAt || o.date)}</div>
        </td>
        <td style="min-width:200px">
          ${buyerAvatar ? `<img src="${buyerAvatar}" style="width:28px;height:28px;border-radius:50%;vertical-align:middle;margin-right:8px">` : ''}
          <span style="vertical-align:middle">${buyerNameDisplay}</span>
          ${buyerPhoneDisplay ? `<div class="small-muted">ðŸ“ž ${buyerPhoneDisplay}</div>` : ''}
          ${buyerRoomDisplay ? `<div class="small-muted">ðŸ  ${buyerRoomDisplay}</div>` : ''}
        </td>
        <td style="max-width:320px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;display:flex;align-items:center">
          <img src="${thumbUrl}" class="row-thumb" alt="thumb">
          <div style="min-width:0">
            <div style="font-weight:700">${escapeHtml(itemsSummary)}</div>
            <div class="small-muted">first item</div>
          </div>
        </td>
        <td>${qty}</td>
        <td><span class="status-badge ${statusClass(o.status)}">${o.status||'Pending'}</span></td>
        <td class="actions"></td>
      `;

      tr.addEventListener('click', e => { if (e.target.closest('.actions')) return; toggleDetailsFor(o); });

      const actTd = tr.querySelector('.actions');
      const st = (o.status||'Pending');

      // ðŸ”¥ ENHANCED: Delivery-request controls (seller-side)
      // Check multiple sources to determine the true assignment status
      const publicRequests = getPublicDeliveryRequests();
      const deliveryRequest = publicRequests.find(req => 
        req.orderId === o.id || req.orderId === o.orderId
      );

      // Check if order is assigned anywhere (local order OR public request)
      const isAssignedInOrder = !!(o.assignedTo || o.assignedDeliveryId);
      const isAssignedInPublicRequest = !!(deliveryRequest && deliveryRequest.assignedTo);
      const isAssigned = isAssignedInOrder || isAssignedInPublicRequest;

      const isRequestActive = !!deliveryRequest && deliveryRequest.status === 'open' && !isAssigned;
      const biddersCount = deliveryRequest ? (deliveryRequest.bids || []).length : 0;
      const assignedTo = o.assignedTo || (deliveryRequest ? deliveryRequest.assignedTo : null) || null;
      const ownerIsDelivering = !!o.ownerIsDelivering;

      // ðŸ†• CHECK IF ORDER IS PICKUP (SHOULD NOT SHOW DELIVERY BUTTONS)
      const isPickupOrder = o.deliveryType === 'pickup';

      // Show bidder count badge if there are bidders and request is still open
      if (biddersCount > 0 && !isAssigned) {
        const badge = document.createElement('span');
        badge.className = 'small-muted';
        badge.style.marginRight = '8px';
        badge.textContent = `Bidders: ${biddersCount}`;
        actTd.appendChild(badge);
      }

      // ðŸ”¥ PRIORITY 1: If assigned anywhere, show "Assigned" immediately
      // ðŸ”¥ PRIORITY 1: If assigned anywhere, show "Assigned" immediately
      if (isAssigned) {
        const assignedBtn = actionBtn('Assigned', 'btn-muted', () => showAssignedCourierDetails(o));
        assignedBtn.style.background = '#10b981';
        assignedBtn.style.color = 'white';
        assignedBtn.innerHTML = '<i class="fas fa-check-circle"></i> Assigned';
        actTd.appendChild(assignedBtn);
      
        // Also show who it's assigned to if we have that info
        if (assignedTo) {
          const assigneeInfo = document.createElement('span');
          assigneeInfo.className = 'small-muted';
          assigneeInfo.style.marginLeft = '8px';
          assigneeInfo.textContent = `to: ${assignedTo}`;
          actTd.appendChild(assigneeInfo);
        }
      }
      // ðŸ”¥ PRIORITY 2: Seller is self-delivering
      else if (ownerIsDelivering) {
        actTd.appendChild(actionBtn('You are delivering','btn-accept', ()=> {
          if (!o.assignedTo) {
            const sellerUid = auth.currentUser?.uid || null;
            if (sellerUid) assignCourier(o.id || o.orderId, sellerUid, 'Seller (self)');
          }
        }));
      } 
      // ðŸ”¥ PRIORITY 3: Active request but not assigned
      else if (isRequestActive) {
        actTd.appendChild(actionBtn('Cancel Request','btn-warn', ()=> cancelDeliveryRequest(o.id || o.orderId)));
        actTd.appendChild(actionBtn('View Bidders','btn-muted', ()=> showBiddersModal(o)));
      }
      // ðŸ”¥ PRIORITY 4: No request yet - ONLY SHOW FOR DELIVERY ORDERS, NOT PICKUP
// ðŸš¨ ONLY SHOW WHEN STATUS IS "Processing"
else if (!isPickupOrder && (o.status || '').toLowerCase() === 'processing') {
  // Only show "Ask for Delivery" button for delivery orders in Processing status
  actTd.appendChild(actionBtn('Ask for Delivery','btn-edit', ()=> {
    askForDelivery(o.id || o.orderId, 300);
  }));
}
// ðŸ†• Optional: Show a message when order is not ready for delivery
else if (!isPickupOrder && ['pending', 'accepted'].includes((o.status || '').toLowerCase())) {
  const notReadyMsg = document.createElement('span');
  notReadyMsg.className = 'small-muted';
  notReadyMsg.style.color = 'var(--muted)';
  notReadyMsg.textContent = 'Complete order steps first';
  actTd.appendChild(notReadyMsg);
}
      // ðŸ†• PRIORITY 5: For pickup orders, show pickup info instead
      else if (isPickupOrder) {
        const pickupInfo = document.createElement('span');
        pickupInfo.className = 'small-muted';
        pickupInfo.style.color = 'var(--primary)';
        pickupInfo.innerHTML = '<i class="fas fa-store"></i> Pickup Order';
        actTd.appendChild(pickupInfo);
      }

      // Order flow actions
      if (st === 'Pending') {
        actTd.appendChild(actionBtn('Accept','btn-accept', ()=> changeOrderStatus(o,'Accepted')));
        actTd.appendChild(actionBtn('Reject','btn-warn', ()=> rejectOrder(o)));
      } else if (st === 'Accepted') {
        actTd.appendChild(actionBtn('Start Processing','btn-edit', ()=> changeOrderStatus(o,'Processing')));
        actTd.appendChild(actionBtn('Reject','btn-warn', ()=> rejectOrder(o)));
      } else if (st === 'Processing') {
        // ðŸ”¥ CHECK IF IT'S A PICKUP ORDER
        if (o.deliveryType === 'pickup') {
          // PICKUP ORDER: Show "Ready for Pickup" button
          actTd.appendChild(actionBtn('Ready for Pickup','btn-accept', ()=> handlePickupOrder(o)));
        } else {
          // DELIVERY ORDER: Show "Start Delivery" button  
          actTd.appendChild(actionBtn('Start Delivery','btn-edit', ()=> changeOrderStatus(o,'Delivering')));
        }
        actTd.appendChild(actionBtn('Reject','btn-warn', ()=> rejectOrder(o)));
      
      } else if (st === 'Ready for Pickup') {
        // ðŸ”¥ PICKUP ORDER READY FOR COLLECTION
        actTd.appendChild(actionBtn('Confirm Pickup','btn-accept', ()=> openPickupConfirmationModal(o)));
        actTd.appendChild(actionBtn('Reject','btn-warn', ()=> rejectOrder(o)));
      } else if (st === 'Delivering') {
        actTd.appendChild(actionBtn('Mark At Door','btn-accept', ()=> changeOrderStatus(o,'At Door')));
        actTd.appendChild(actionBtn('Reject','btn-warn', ()=> rejectOrder(o)));
      } else if (st === 'At Door') {
        actTd.appendChild(actionBtn('Confirm Delivery','btn-accept', ()=> openConfirmCodeModal(o)));
        actTd.appendChild(actionBtn('Reject','btn-warn', ()=> rejectOrder(o)));
      } else {
        actTd.appendChild(actionBtn('Details','btn-muted', ()=> toggleDetailsFor(o)));
      }

      if (!actTd.querySelector('.btn-muted')) {
        actTd.appendChild(actionBtn('Details','btn-muted', ()=> toggleDetailsFor(o)));
      }

      ordersTbody.appendChild(tr);

      // details row (render full bidder details inline)
      const detailsTr = document.createElement('tr'); detailsTr.className='details-row'; detailsTr.style.display='none';
      const td = document.createElement('td'); td.colSpan=6;

      const baseHtml = renderOrderDetailsHtml(o);

      const bidsArr = Array.isArray(o.bids) && o.bids.length ? o.bids : (Array.isArray(o.bidders) ? o.bidders.map(b => ( {
        bidderId: b.id || b.bidderId || '',
        bidderName: b.name || b.bidderName || '',
        bidderAvatar: b.profilePictureUrl || b.bidderAvatar || '',
        bidderPhone: b.phone || b.phone || '',
        bidderEmail: b.email || b.email || '',
        bidderIndex: b.index || b.index || '',
        bidderProgram: b.program || b.program || '',
        bidderRoom: b.room || b.room || '',
        amount: (typeof b.amount !== 'undefined' ? b.amount : (b.bidAmount || null)),
        eta: b.eta || null,
        placedAt: b.placedAt || b.requestedAt || b.requested || nowISO()
      })) : []);

      const biddersHtml = (bidsArr.length ? `<div style="margin-top:10px"><strong>Bidders (${bidsArr.length})</strong><div style="display:flex;flex-direction:column;gap:8px;margin-top:8px">` + bidsArr.map(b => {
        const bidId = escapeHtml(b.bidderId || b.id || '');
        const name = escapeHtml(b.bidderName || b.bidderName || b.name || bidId);
        const avatar = escapeHtml(b.bidderAvatar || b.profilePictureUrl || '../../images/no profile pic.jpg');
        const amountText = (typeof b.amount !== 'undefined' && b.amount !== null) ? `GHC ${Number(b.amount).toFixed(2)}` : '';
        const etaText = b.eta ? ` â€¢ ETA: ${escapeHtml(String(b.eta))} min` : '';
        const placed = b.placedAt ? fmtDate(b.placedAt) : '';
        return `
          <div style="padding:10px;border-radius:8px;border:1px solid #f0f0f0;display:flex;gap:12px;align-items:flex-start;background:#fff">
            <img src="${avatar}" style="width:64px;height:64px;border-radius:8px;object-fit:cover">
            <div style="flex:1">
              <div style="font-weight:800;font-size:15px">${name}</div>
              <div class="small-muted" style="margin-top:4px">UID: ${bidId}</div>
              ${ (amountText || etaText) ? `<div class="small-muted" style="margin-top:8px">${escapeHtml(amountText)}${escapeHtml(etaText)}</div>` : '' }
              ${ b.bidderPhone ? `<div class="small-muted" style="margin-top:6px">ðŸ“ž ${escapeHtml(b.bidderPhone)}</div>` : '' }
              ${ b.bidderEmail ? `<div class="small-muted">âœ‰ï¸ ${escapeHtml(b.bidderEmail)}</div>` : '' }
              ${ b.bidderIndex ? `<div class="small-muted">Index: ${escapeHtml(b.bidderIndex)}</div>` : '' }
              ${ b.bidderProgram ? `<div class="small-muted">Program: ${escapeHtml(b.bidderProgram)}</div>` : '' }
              ${ b.bidderRoom ? `<div class="small-muted">Room: ${escapeHtml(b.bidderRoom)}</div>` : '' }
              <div class="small-muted" style="margin-top:8px;font-size:12px">Placed: ${escapeHtml(placed)}</div>
            </div>
            <div style="display:flex;flex-direction:column;gap:8px">
              <button class="btn btn-accept" data-bid-id="${bidId}" data-order-id="${escapeHtml(o.id||o.orderId||'')}">Assign</button>
              <button class="btn btn-warn" data-bid-remove="${bidId}" data-order-id="${escapeHtml(o.id||o.orderId||'')}">Remove</button>
            </div>
          </div>
        `;
      }).join('') + `</div></div>` : `<div style="margin-top:10px" class="small-muted">No bidders yet.</div>`);

      td.innerHTML = baseHtml + biddersHtml;
      detailsTr.appendChild(td);
      ordersTbody.appendChild(detailsTr);

      // resolve assigned info async (existing behavior)
      if (o.assignedTo || o.assignedDeliveryId) {
        (async ()=>{
          try {
            const uid = o.assignedTo || o.assignedDeliveryId;
            const assignedPlaceholderId = `assigned-info-${sanitizeDomId(o.id||o.orderId)}`;
            const el = document.getElementById(assignedPlaceholderId);
            if (!el) return;
            const profile = await getSellerInfo(uid);
            if (profile) {
              el.innerHTML = `
                <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
                  <img src="${profile.profilePictureUrl||'../../images/no profile pic.jpg'}" style="width:36px;height:36px;border-radius:6px;object-fit:cover;margin-right:8px">
                  <div>
                    <strong>${escapeHtml(profile.name||uid)}</strong>
                    <div class="small-muted">${escapeHtml(uid)}</div>
                  </div>
                </div>
                <div class="small-muted">ðŸ“ž ${escapeHtml(profile.phone||'')}</div>
                <div class="small-muted">âœ‰ï¸ ${escapeHtml(profile.email||'')}</div>
                ${profile.index ? `<div class="small-muted">Index: ${escapeHtml(profile.index)}</div>` : ''}
                ${profile.program ? `<div class="small-muted">Program: ${escapeHtml(profile.program)}</div>` : ''}
                ${profile.room ? `<div class="small-muted">Room: ${escapeHtml(profile.room)}</div>` : ''}
              `;
            } else {
              el.textContent = `Assigned courier: ${escapeHtml(uid)}`;
            }
          } catch(e){}
        })();
      }

    }); // end list.forEach

    // === EVENT DELEGATION - MAKES ASSIGN/REMOVE BUTTONS WORK ===
    try {
      if (ordersTbody && !ordersTbody._delegationAttached) {
        ordersTbody.addEventListener('click', (e) => {
          const assignBtn = e.target.closest('[data-bid-id]');
          if (assignBtn) {
            e.stopPropagation();
            const bidId = assignBtn.getAttribute('data-bid-id');
            const orderId = assignBtn.getAttribute('data-order-id');
            if (!confirm('Assign this bidder to the order?')) return;
            (async ()=> {
              let friendly = bidId;
              try {
                const profile = await getSellerInfo(bidId);
                if (profile && profile.name) friendly = profile.name;
              } catch(e){}
              assignCourier(orderId, bidId, friendly);
              if (biddersModal) biddersModal.style.display='none';
            })();
            return;
          }

          const removeBtn = e.target.closest('[data-bid-remove]');
          if (removeBtn) {
            e.stopPropagation();
            const rid = removeBtn.getAttribute('data-bid-remove');
            const orderId = removeBtn.getAttribute('data-order-id');
            if (!confirm('Remove this bidder?')) return;
            removeBid(orderId, rid);
            return;
          }
        });
        ordersTbody._delegationAttached = true;
      }
    } catch (err) { console.warn('delegation attach failed', err); }
    // === END EVENT DELEGATION ===

    // update badge (count active orders) â€” use reconciled sellerOrders
    const activeCount = (sellerOrders || []).filter(o => ['Pending','Accepted','Processing','Delivering','At Door','Assigned'].includes(o.status)).length;
    updateOrdersBadge(activeCount);

    if (notifyNew) showToast('New order received','success');

    renderAnalytics();
    lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';
  } catch (err) {
    console.error('renderOrders failed', err);
  }
}

/* ---------- Completed / History rendering ---------- */
function renderCompletedOrders() {
  if (!completedTbody) return;
  completedTbody.innerHTML = '';
  completedOrders = JSON.parse(localStorage.getItem(completedOrdersKey()) || '[]') || [];

  const sTerm = (historySearch?.value||'').toLowerCase();
  if (!completedOrders.length) {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td colspan="7" style="text-align:center;color:var(--muted)">No completed orders yet</td>`;
    completedTbody.appendChild(tr);
    return;
  }

  const list = completedOrders.slice().reverse().filter(o => {
    const buyerObj = (o.buyer && typeof o.buyer === 'object') ? o.buyer : null;
    const buyerSearch = `${buyerObj?.name||o.buyerName||o.buyer||o.customer||''} ${buyerObj?.phone||o.phone||''}`;
    const combined = `${buyerSearch} ${JSON.stringify(o.items||o.product||'')}`;
    return (!sTerm || combined.toLowerCase().includes(sTerm) || String(o.id||'').includes(sTerm));
  });

  list.forEach(o => {
    const tr = document.createElement('tr');

    // ðŸŽ¯ Add visual indicator for rejected orders
    const isRejected = o.status === 'Rejected';
    const isDelivered = o.status === 'Delivered' || o.status === 'Picked Up';
    
    if (isRejected) {
      tr.style.backgroundColor = 'rgba(239, 68, 68, 0.05)';
      tr.style.borderLeft = '4px solid var(--danger)';
    }

    const thumbUrl = orderThumbnail(o) || 'https://via.placeholder.com/90';
    const itemsSummary = Array.isArray(o.items) ? o.items.map(i=>i.name).join(', ') : (o.product||'-');
    const qty = Array.isArray(o.items) ? o.items.reduce((s,i)=>s+(i.quantity||1),0) : (o.quantity||1);
    
    // ðŸŽ¯ CORRECT LOGIC: Calculate revenue based on status
    let sellerRevenue = 0;
    let revenueDisplay = '';
    let statusIndicator = '';
    
    if (isRejected) {
      sellerRevenue = 0;
      revenueDisplay = `<span style="color:var(--danger);text-decoration:line-through">GHC 0.00</span>`;
      statusIndicator = `<span class="status-badge s-rejected" style="margin-left:8px;font-size:0.7rem">REJECTED</span>`;
    } else if (isDelivered) {
      const productRevenue = o.subtotal || 0;
      const deliveryFee = o.delivery || o.deliveryFee || 0;
      const sellerDelivered = !o.assignedTo && !o.assignedDeliveryId;
      
      if (sellerDelivered) {
        sellerRevenue = productRevenue + deliveryFee;
      } else {
        const courierEarnings = o.courierEarnings || o.assignedBidAmount || 0;
        const deliveryProfit = deliveryFee - courierEarnings;
        sellerRevenue = productRevenue + deliveryProfit;
      }
      revenueDisplay = `<span style="color:var(--success);font-weight:600">GHC ${Number(sellerRevenue||0).toFixed(2)}</span>`;
      statusIndicator = o.status === 'Picked Up' 
        ? `<span class="status-badge s-delivered" style="margin-left:8px;font-size:0.7rem">PICKUP</span>`
        : `<span class="status-badge s-delivered" style="margin-left:8px;font-size:0.7rem">DELIVERED</span>`;
    }

    // buyer fields
    const buyerObj = (o.buyer && typeof o.buyer === 'object') ? o.buyer : null;
    const buyerNameDisplay = escapeHtml(buyerObj?.name || o.buyerName || o.buyer || o.customer || 'Anonymous');
    const buyerPhoneDisplay = escapeHtml(buyerObj?.phone || o.phone || '');

    // ðŸŽ¯ Show correct timestamp
    const actionTimestamp = isRejected ? o.rejectedAt : (o.deliveredAt || o.delivered || o.completedAt || o.pickedUpAt || '');
    const actionText = isRejected ? 'Rejected' : (o.status === 'Picked Up' ? 'Picked Up' : 'Delivered');

    tr.innerHTML = `
      <td>
        ${escapeHtml(o.id || o.orderId || '')}
        ${statusIndicator}
      </td>
      <td>
        ${buyerNameDisplay}
        ${buyerPhoneDisplay ? `<div class="small-muted">ðŸ“ž ${buyerPhoneDisplay}</div>` : ''}
        ${isRejected ? '<div class="small-muted" style="color:var(--danger);font-size:0.75rem">âŒ Order Rejected</div>' : 
          (!o.assignedTo && !o.assignedDeliveryId) ? '<div class="small-muted" style="color:var(--primary);font-size:0.75rem">ðŸš— Self-delivered</div>' : ''}
      </td>
      <td style="display:flex;align-items:center;max-width:320px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">
        <img src="${thumbUrl}" class="row-thumb" alt="thumb">
        <div style="min-width:0">
          <div style="font-weight:700">${escapeHtml(itemsSummary)}</div>
        </div>
      </td>
      <td>${qty}</td>
      <td>${revenueDisplay}</td>
      <td>
        ${fmtDate(actionTimestamp)}
        <div class="small-muted" style="font-size:0.75rem">${actionText}</div>
      </td>
      <td class="actions"></td>
    `;

    const actTd = tr.querySelector('.actions');
    actTd.appendChild(actionBtn('Details','btn-muted', ()=> toggleCompletedDetailsFor(o)));

    completedTbody.appendChild(tr);

    const detailsTr = document.createElement('tr'); 
    detailsTr.className='completed-details-row'; 
    detailsTr.style.display='none';
    const td = document.createElement('td'); 
    td.colSpan=7; 
    td.innerHTML = renderCompletedOrderDetailsHtml(o); 
    detailsTr.appendChild(td);
    completedTbody.appendChild(detailsTr);
  });
}

function toggleCompletedDetailsFor(orderObj){
  const rows = Array.from(completedTbody.querySelectorAll('tr'));
  for(let i=0;i<rows.length;i+=2){
    const main=rows[i], details=rows[i+1]; if(!main) continue;
    const idCell = main.cells[0]?.textContent||'';
    if(idCell.includes(String(orderObj.id||orderObj.orderId||''))){
      details.style.display = details.style.display==='table-row'?'none':'table-row';
      return;
    }
  }
}

function renderCompletedOrderDetailsHtml(o){
  const items = Array.isArray(o.items) ? o.items : (o.product ? [{name:o.product,price:o.price||0,quantity:o.quantity||1}] : []);
  const itemsHtml = items.map(it => `<div class="order-item" style="display:flex;gap:10px;align-items:center;margin-bottom:10px"><img class="item-thumb" src="${it.image||orderThumbnail(o)||'https://via.placeholder.com/90'}" style="width:72px;height:72px;object-fit:cover;border-radius:6px"><div><div style="font-weight:700">${escapeHtml(it.name)}</div><div class="small-muted">Price: GHC ${(it.price||0).toFixed(2)} â€¢ Qty: ${it.quantity||1}</div></div></div>`).join('');
  
  const subtotal = o.subtotal || items.reduce((s,i)=>s+(i.price||0)*(i.quantity||1),0);
  const deliveryFee = o.delivery || (o.deliveryFee||0);
  const totalOrderValue = subtotal + deliveryFee;
  
  // ðŸŽ¯ FIX: Handle REJECTED vs DELIVERED orders differently
  const isRejected = o.status === 'Rejected';
  const isDelivered = o.status === 'Delivered' || o.status === 'Picked Up';
  
  let revenueHtml = '';
  let statusBadge = '';
  
  if (isRejected) {
    // REJECTED ORDER - Show $0 revenue
    revenueHtml = `
      <div style="margin-top:8px">
        <div class="small-muted">Order Value: <span style="text-decoration:line-through;color:var(--danger)">GHC ${Number(totalOrderValue||0).toFixed(2)}</span></div>
        <div class="small-muted" style="color:var(--danger);font-weight:600">Rejected Revenue: GHC 0.00</div>
      </div>
    `;
    statusBadge = `<span class="status-badge s-rejected" style="margin-left:8px">REJECTED</span>`;
  } else if (isDelivered) {
    // DELIVERED ORDER - Show actual revenue calculation
    const courierEarnings = o.courierEarnings || o.assignedBidAmount || 0;
    const deliveryProfit = o.deliveryProfit || (deliveryFee - courierEarnings);
    const sellerRevenue = subtotal + deliveryProfit;
    
    revenueHtml = `
      <div style="margin-top:8px">
        <div class="small-muted">Order Value: GHC ${Number(totalOrderValue||0).toFixed(2)}</div>
        <div class="small-muted">Subtotal: GHC ${Number(subtotal||0).toFixed(2)}</div>
        <div class="small-muted">Delivery Fee: GHC ${Number(deliveryFee||0).toFixed(2)}</div>
        ${courierEarnings > 0 ? `<div class="small-muted">Courier Earnings: GHC ${Number(courierEarnings||0).toFixed(2)}</div>` : ''}
        ${deliveryProfit > 0 ? `<div class="small-muted" style="color:var(--success);font-weight:600">Delivery Profit: GHC ${Number(deliveryProfit||0).toFixed(2)}</div>` : ''}
        <div style="margin-top:8px;font-weight:800;color:var(--success)">Your Revenue: GHC ${Number(sellerRevenue||0).toFixed(2)}</div>
      </div>
    `;
    statusBadge = `<span class="status-badge s-delivered" style="margin-left:8px">DELIVERED</span>`;
  }

  // buyer fields
  const buyerObj = (o.buyer && typeof o.buyer === 'object') ? o.buyer : null;
  const buyerName = escapeHtml(buyerObj?.name || o.buyerName || o.buyer || o.customer || 'Anonymous');
  const buyerPhone = escapeHtml(buyerObj?.phone || o.phone || '');
  const buyerRoom = escapeHtml(buyerObj?.room || buyerObj?.roomNumber || buyerObj?.roomnumber || o.room || '');
  const buyerEmail = escapeHtml(buyerObj?.email || o.email || '');
  const buyerIndex = escapeHtml(buyerObj?.index || o.index || '');
  const buyerProgram = escapeHtml(buyerObj?.program || '');
  const buyerAvatar = buyerObj?.profilePictureUrl || '';

  // ðŸŽ¯ FIX: Show correct timestamp based on status
  const actionTimestamp = isRejected ? o.rejectedAt : (o.deliveredAt || o.delivered || o.completedAt || o.pickedUpAt || '');
  const actionText = isRejected ? 'Rejected' : (o.status === 'Picked Up' ? 'Picked Up' : 'Delivered');

  return `<div class="order-details" style="display:flex;gap:12px;align-items:flex-start;justify-content:space-between">
    <div style="flex:1">
      <div style="font-weight:700;display:flex;align-items:center">
        Items ${statusBadge}
      </div>
      <div class="order-items" style="margin-top:8px">${itemsHtml}</div>
    </div>
    <div style="width:320px">
      <div style="font-weight:700">Order Summary</div>
      <div class="small-muted">Placed: ${fmtDate(o.date || o.appearedAt)}</div>
      <div class="small-muted">${actionText}: ${fmtDate(actionTimestamp)}</div>
      
      ${revenueHtml}
      
      ${o.deliveryPerson?`<div class="small-muted">Courier: ${escapeHtml(o.deliveryPerson)}</div>`:''}
      
      <hr style="margin:10px 0;border:none;border-top:1px solid #eee">
      
      <div style="font-weight:700">Buyer Information</div>
      ${buyerAvatar ? `<div style="margin-top:6px;margin-bottom:6px"><img src="${buyerAvatar}" alt="${buyerName}" style="width:64px;height:64px;border-radius:8px;object-fit:cover"></div>` : ''}
      <div class="small-muted" style="margin-top:6px">${buyerName}</div>
      ${buyerPhone?`<div class="small-muted">ðŸ“ž ${buyerPhone}</div>` : ''}
      ${buyerEmail?`<div class="small-muted">âœ‰ï¸ ${buyerEmail}</div>` : ''}
      ${buyerRoom?`<div class="small-muted">ðŸ  ${buyerRoom}</div>` : ''}
      ${buyerIndex?`<div class="small-muted">ðŸ†” ${buyerIndex}</div>` : ''}
      ${buyerProgram?`<div class="small-muted">ðŸŽ“ ${buyerProgram}</div>` : ''}
      
      ${isRejected ? `
        <hr style="margin:10px 0;border:none;border-top:1px solid var(--danger)">
        <div style="color:var(--danger);font-size:0.85rem">
          <i class="fas fa-exclamation-triangle"></i> This order was rejected. No revenue was earned.
        </div>
      ` : ''}
    </div>
  </div>`;
}

/* ---------- Small helpers & UI actions ---------- */
function actionBtn(label, cls, cb){
  const b = document.createElement('button'); b.className = 'btn ' + (cls||'btn-muted'); b.textContent = label;
  b.addEventListener('click', e=>{ e.stopPropagation(); cb(); });
  return b;
}

function toggleDetailsFor(orderObj){
  const rows = Array.from(ordersTbody.querySelectorAll('tr'));
  for(let i=0;i<rows.length;i+=2){
    const main=rows[i], details=rows[i+1]; if(!main) continue;
    const idCell = main.cells[0]?.textContent||'';
    if(idCell.includes(String(orderObj.id||orderObj.orderId||''))){ 
      details.style.display = details.style.display==='table-row'?'none':'table-row';
      return;
    }
  }
}

/* ---------- Pickup Order Flow ---------- */
function handlePickupOrder(orderRef) {
  try {
    const orderId = typeof orderRef === 'object' ? (orderRef.id || orderRef.orderId) : String(orderRef);
    
    if (!confirm(`Mark order #${orderId} as ready for pickup? Buyer will be notified to come collect.`)) return;

    // Update order status to "Ready for Pickup"
    changeOrderStatus(orderRef, 'Ready for Pickup');
    
    showToast('Order marked ready for pickup!', 'success');
    
  } catch (err) {
    console.error('handlePickupOrder failed:', err);
    showToast('Error marking order ready for pickup', 'error');
  }
}

function openPickupConfirmationModal(order) {
  let pickupModal = document.getElementById('pickupConfirmationModal');
  if (!pickupModal) {
    pickupModal = document.createElement('div');
    pickupModal.id = 'pickupConfirmationModal';
    pickupModal.className = 'modal';
    pickupModal.innerHTML = `
      <div class="modal-card">
        <h3>Confirm Pickup Completion</h3>
        <div style="margin-bottom:16px">
          <div class="small-muted">Ask the buyer for their pickup code:</div>
          <input id="pickupCodeInput" class="input" placeholder="Enter 6-digit code" style="width:100%;margin-top:8px">
          <div class="small-muted" style="margin-top:4px">Order #${order.id || order.orderId}</div>
        </div>
        <div style="display:flex;gap:8px;justify-content:flex-end">
          <button id="cancelPickup" class="btn btn-warn">Cancel</button>
          <button id="confirmPickup" class="btn btn-accept">Confirm Pickup</button>
        </div>
      </div>
    `;
    document.body.appendChild(pickupModal);
    
    pickupModal.querySelector('#cancelPickup').addEventListener('click', () => {
      pickupModal.style.display = 'none';
    });
    
    pickupModal.querySelector('#confirmPickup').addEventListener('click', () => {
      confirmPickupCompletion(order);
    });
  }

  document.getElementById('pickupCodeInput').value = '';
  pickupModal.style.display = 'flex';
}

function confirmPickupCompletion(order) {
  try {
    const codeInput = document.getElementById('pickupCodeInput');
    const enteredCode = codeInput.value.trim();
    
    if (!enteredCode) {
      showToast('Please enter the pickup code', 'error');
      return;
    }

    // Verify pickup code
    if (enteredCode !== String(order.deliveryCode)) {
      showToast('Incorrect pickup code', 'error');
      return;
    }

    // âœ… Code is correct - mark as "Picked Up"
    const globalOrders = getGlobalOrders();
    const globalIdx = globalOrders.findIndex(o => 
      String(o.id) === String(order.id) || String(o.orderId) === String(order.orderId)
    );

    if (globalIdx === -1) {
      showToast('Order not found in global storage', 'error');
      return;
    }

    const globalOrder = globalOrders[globalIdx];
    const oldStatus = globalOrder.status;
    
    // Update to "Picked Up" (NOT "Delivered")
    globalOrder.status = 'Picked Up';
    globalOrder.progressStep = 5; // Final step for pickup orders
    globalOrder.pickedUpAt = new Date().toISOString();
    
    // Add to history
    if (!globalOrder.history) globalOrder.history = [];
    globalOrder.history.push({
      from: oldStatus,
      to: 'Picked Up',
      by: 'seller_pickup',
      at: globalOrder.pickedUpAt,
      note: 'Pickup completed with code verification'
    });

    // Save to global
    globalOrders[globalIdx] = globalOrder;
    saveGlobalOrders(globalOrders);

    // Notify buyer
    const buyerUid = globalOrder.buyer?.uid || globalOrder.buyerId;
    if (buyerUid) {
      localStorage.setItem(`orders_ping__buyer__${buyerUid}`, String(Date.now()));
    }

    // Update seller local and move to completed
    let sellerOrders = JSON.parse(localStorage.getItem(ordersKey()) || '[]');
    const sellerIdx = sellerOrders.findIndex(o => 
      String(o.id) === String(order.id) || String(o.orderId) === String(order.orderId)
    );
    
    if (sellerIdx !== -1) {
      // Remove from active orders
      sellerOrders.splice(sellerIdx, 1);
      localStorage.setItem(ordersKey(), JSON.stringify(sellerOrders));
      
      // Add to completed orders
      const compKey = completedOrdersKey();
      const completed = JSON.parse(localStorage.getItem(compKey) || '[]');
      completed.unshift(globalOrder);
      localStorage.setItem(compKey, JSON.stringify(completed));
    }

    // Close modal
    const pickupModal = document.getElementById('pickupConfirmationModal');
    if (pickupModal) pickupModal.style.display = 'none';

    // Refresh UI
    renderOrders();
    renderCompletedOrders();
    renderAnalytics();
    
    showToast('Pickup completed successfully!', 'success');

  } catch (err) {
    console.error('confirmPickupCompletion failed:', err);
    showToast('Error confirming pickup', 'error');
  }
}

/* ---------- Change Order Status (seller-driven; decrement at Processing) ---------- */

/* ---------- Change Order Status (MINIMAL FIX) ---------- */
/* ---------- Change Order Status (MINIMAL FIX) ---------- */
function changeOrderStatus(orderRef, newStatus) {
  try {
    console.log('ðŸŽ¯ changeOrderStatus called:', { orderRef, newStatus });
    
    const orderId = typeof orderRef === 'object' ? (orderRef.id || orderRef.orderId) : String(orderRef);
    console.log('ðŸ“‹ Order ID:', orderId);
    
    // SIMPLE: Just update global orders
    const globalOrders = getGlobalOrders();
    console.log('ðŸ“¦ Global orders count:', globalOrders.length);
    
    const orderIndex = globalOrders.findIndex(o => 
      String(o.id) === String(orderId) || String(o.orderId) === String(orderId)
    );
    
    console.log('ðŸ” Order found at index:', orderIndex);
    
    if (orderIndex !== -1) {
      const oldOrder = globalOrders[orderIndex];
      globalOrders[orderIndex].status = newStatus;
      globalOrders[orderIndex].progressStep = getProgressStep(newStatus);
      globalOrders[orderIndex].statusUpdatedAt = nowISO();
      
      // ðŸ†• CRITICAL: Track the courier who's assigned
      const assignedCourierId = oldOrder.assignedTo || oldOrder.assignedDeliveryId;
      
      // Save global first
      saveGlobalOrders(globalOrders);
      
      console.log('âœ… Updated global order status to:', newStatus);
      
      // ðŸ†• SYNC TO DELIVERY GUY'S STORAGE
      if (assignedCourierId) {
        syncToDeliveryGuy(globalOrders[orderIndex], assignedCourierId);
      }
      
      // ðŸ†• SYNC TO BUYER'S STORAGE
      syncToBuyer(globalOrders[orderIndex]);
      
      // ðŸš¨ AUTO-REDUCE PRODUCT STOCK WHEN ORDER GOES TO PROCESSING
      if (newStatus.toLowerCase() === 'processing') {
        console.log('ðŸ”„ Calling reduceProductStock for processing order...');
        reduceProductStock(globalOrders[orderIndex]);
      }
      
      // Notify buyer
      const buyerUid = globalOrders[orderIndex]?.buyer?.uid;
      if (buyerUid) {
        localStorage.setItem(`orders_ping__buyer__${buyerUid}`, Date.now().toString());
        console.log('ðŸ“¢ Notified buyer:', buyerUid);
      }
      
      // ðŸ†• NOTIFY DELIVERY GUY
      if (assignedCourierId) {
        localStorage.setItem(`orders_ping__delivery__${assignedCourierId}`, Date.now().toString());
        console.log('ðŸ“¢ Notified delivery guy:', assignedCourierId);
      }
    }

    // Update seller local (optional)
    let sellerOrders = JSON.parse(localStorage.getItem(ordersKey()) || '[]');
    const sellerIndex = sellerOrders.findIndex(o => 
      String(o.id) === String(orderId) || String(o.orderId) === String(orderId)
    );
    if (sellerIndex !== -1) {
      sellerOrders[sellerIndex].status = newStatus;
      sellerOrders[sellerIndex].progressStep = getProgressStep(newStatus);
      localStorage.setItem(ordersKey(), JSON.stringify(sellerOrders));
      console.log('âœ… Updated seller local order');
    }

    renderOrders();
    showToast(`Order â†’ ${newStatus}`, 'success');
    
    console.log('ðŸŽ‰ changeOrderStatus completed successfully');

  } catch (err) {
    console.error('âŒ changeOrderStatus error:', err);
    showToast('Update failed', 'error');
  }
}

/* ---------- NEW: Sync to Delivery Guy ---------- */
function syncToDeliveryGuy(order, courierUid) {
  try {
    if (!courierUid) return;
    
    const deliveryOrdersKey = `orders__delivery__${courierUid}`;
    let deliveryOrders = JSON.parse(localStorage.getItem(deliveryOrdersKey) || '[]');
    
    const orderIndex = deliveryOrders.findIndex(o => 
      String(o.id) === String(order.id) || String(o.orderId) === String(order.orderId)
    );
    
    if (orderIndex !== -1) {
      // Update existing order
      deliveryOrders[orderIndex] = {
        ...deliveryOrders[orderIndex],
        status: order.status,
        progressStep: order.progressStep,
        statusUpdatedAt: order.statusUpdatedAt,
        // Preserve delivery-specific fields
        assignedTo: deliveryOrders[orderIndex].assignedTo || order.assignedTo,
        assignedDeliveryId: deliveryOrders[orderIndex].assignedDeliveryId || order.assignedDeliveryId,
        courierEarnings: deliveryOrders[orderIndex].courierEarnings || order.courierEarnings,
        assignedBidAmount: deliveryOrders[orderIndex].assignedBidAmount || order.assignedBidAmount,
        // Update history
        history: [
          ...(deliveryOrders[orderIndex].history || []),
          {
            action: 'status_updated_by_seller',
            from: deliveryOrders[orderIndex].status,
            to: order.status,
            at: order.statusUpdatedAt,
            by: 'seller'
          }
        ]
      };
    } else {
      // Add new order (this shouldn't happen but just in case)
      deliveryOrders.unshift(order);
    }
    
    localStorage.setItem(deliveryOrdersKey, JSON.stringify(deliveryOrders));
    console.log('âœ… Synced to delivery guy storage:', courierUid);
    
  } catch (error) {
    console.error('âŒ Failed to sync to delivery guy:', error);
  }
}

/* ---------- NEW: Sync to Buyer ---------- */
function syncToBuyer(order) {
  try {
    const buyerUid = order.buyer?.uid || order.buyerId;
    if (!buyerUid) return;
    
    const buyerOrdersKey = `orders__buyer__${buyerUid}`;
    let buyerOrders = JSON.parse(localStorage.getItem(buyerOrdersKey) || '[]');
    
    const orderIndex = buyerOrders.findIndex(o => 
      String(o.id) === String(order.id) || String(o.orderId) === String(order.orderId)
    );
    
    if (orderIndex !== -1) {
      // Update existing order
      buyerOrders[orderIndex] = {
        ...buyerOrders[orderIndex],
        status: order.status,
        progressStep: order.progressStep,
        statusUpdatedAt: order.statusUpdatedAt
      };
    }
    
    localStorage.setItem(buyerOrdersKey, JSON.stringify(buyerOrders));
    console.log('âœ… Synced to buyer storage:', buyerUid);
    
  } catch (error) {
    console.error('âŒ Failed to sync to buyer:', error);
  }
}

/* ---------- Reject (moves order to completedOrders as 'Rejected') ---------- */
/* ---------- Reject Order (UPDATES GLOBAL) ---------- */
/* ---------- Reject Order (UPDATES GLOBAL + DELIVERY GUY) ---------- */
/* ---------- Enhanced Reject Order Function ---------- */
function rejectOrder(orderRef) {
  try {
    console.log('ðŸŽ¯ rejectOrder called:', orderRef);
    
    const orderId = typeof orderRef === 'object' ? (orderRef.id || orderRef.orderId) : String(orderRef);
    
    // Get confirmation with financial warning
    const subtotal = orderRef.subtotal || 0;
    const deliveryFee = orderRef.delivery || orderRef.deliveryFee || 0;
    const totalValue = subtotal + deliveryFee;
    
    const confirmMsg = totalValue > 0 
      ? `Reject this order worth GHC ${totalValue.toFixed(2)}? This will cancel the transaction. The buyer will be refunded.`
      : 'Reject this order? It will be moved to history as Rejected.';
    
    if (!confirm(confirmMsg)) return;

    // 1. UPDATE GLOBAL ORDERS
    const globalOrders = getGlobalOrders();
    const globalIdx = globalOrders.findIndex(o => 
      String(o.id) === String(orderId) || String(o.orderId) === String(orderId)
    );
    
    if (globalIdx === -1) {
      showToast('Order not found in global storage', 'error');
      return;
    }

    const globalOrder = globalOrders[globalIdx];
    const oldStatus = globalOrder.status || 'Pending';
    const rejectedAt = new Date().toISOString();

    console.log('ðŸ“¦ Updating global order to Rejected');

    // ðŸ”¥ CRITICAL FIX: Preserve ALL financial data
    const enhancedOrder = {
      ...globalOrder,
      status: 'Rejected',
      progressStep: 0,
      rejectedAt,
      // ðŸŽ¯ FINANCIAL DATA PRESERVATION
      subtotal: globalOrder.subtotal || 0,
      delivery: globalOrder.delivery || globalOrder.deliveryFee || 0,
      total: globalOrder.total || (globalOrder.subtotal + (globalOrder.delivery || globalOrder.deliveryFee || 0)),
      // ðŸŽ¯ ZERO REVENUE FOR REJECTED ORDERS
      sellerRevenue: 0,
      deliveryProfit: 0,
      courierEarnings: 0,
      // History with financial context
      history: [
        ...(globalOrder.history || []),
        { 
          from: oldStatus, 
          to: 'Rejected', 
          by: 'seller', 
          at: rejectedAt,
          financials: {
            orderValue: globalOrder.total || 0,
            subtotal: globalOrder.subtotal || 0,
            deliveryFee: globalOrder.delivery || 0,
            sellerRevenue: 0,
            note: 'Order rejected - no revenue earned'
          }
        }
      ]
    };
    
    globalOrders[globalIdx] = enhancedOrder;
    saveGlobalOrders(globalOrders);
    console.log('âœ… Updated global order with financial data');

    // 2. UPDATE DELIVERY GUY (if assigned)
    try {
      const assignedTo = enhancedOrder.assignedTo || enhancedOrder.assignedDeliveryId;
      if (assignedTo) {
        const deliveryGuyOrdersKey = `orders__delivery__${assignedTo}`;
        const deliveryGuyOrders = JSON.parse(localStorage.getItem(deliveryGuyOrdersKey) || '[]');
        
        const deliveryIdx = deliveryGuyOrders.findIndex(o => 
          String(o.id) === String(orderId) || String(o.orderId) === String(orderId)
        );
        
        if (deliveryIdx !== -1) {
          deliveryGuyOrders[deliveryIdx] = {
            ...deliveryGuyOrders[deliveryIdx],
            ...enhancedOrder
          };
          
          localStorage.setItem(deliveryGuyOrdersKey, JSON.stringify(deliveryGuyOrders));
          localStorage.setItem(`orders_ping__delivery__${assignedTo}`, String(Date.now()));
          console.log('âœ… Updated delivery guy storage');
        }
      }
    } catch (err) {
      console.warn('Delivery guy update failed', err);
    }

    // 3. UPDATE BUYER
    try {
      const buyerUid = enhancedOrder.buyer?.uid || enhancedOrder.buyerId || null;
      if (buyerUid) {
        const buyerOrdersKey = `orders__buyer__${buyerUid}`;
        const buyerOrders = JSON.parse(localStorage.getItem(buyerOrdersKey) || '[]');
        const bIdx = buyerOrders.findIndex(o => String(o.id) === String(orderId));
        
        if (bIdx !== -1) {
          buyerOrders[bIdx] = {
            ...buyerOrders[bIdx],
            ...enhancedOrder
          };
          console.log('âœ… Updated buyer order');
        } else {
          buyerOrders.unshift(enhancedOrder);
          console.log('âœ… Added rejected order to buyer');
        }
        
        localStorage.setItem(buyerOrdersKey, JSON.stringify(buyerOrders));
        localStorage.setItem(`orders_ping__buyer__${buyerUid}`, String(Date.now()));
        console.log('ðŸ“¢ Notified buyer');
      }
    } catch (err) {
      console.warn('Buyer update failed', err);
    }

    // 4. UPDATE SELLER LOCAL - Add to completed orders with clear rejection label
    try {
      let sellerOrders = JSON.parse(localStorage.getItem(ordersKey()) || '[]');
      const sIdx = sellerOrders.findIndex(o => 
        String(o.id) === String(orderId) || String(o.orderId) === String(orderId)
      );
      if (sIdx !== -1) {
        sellerOrders.splice(sIdx, 1); // Remove from active seller orders
        localStorage.setItem(ordersKey(), JSON.stringify(sellerOrders));
        console.log('âœ… Removed from seller active orders');
      }
      
      // Add to seller completed history with REJECTED label
      const compKey = completedOrdersKey();
      const completed = JSON.parse(localStorage.getItem(compKey) || '[]');
      completed.unshift({
        ...enhancedOrder,
        // Add visual indicator for rejected orders
        _isRejected: true,
        _rejectedTimestamp: rejectedAt
      });
      localStorage.setItem(compKey, JSON.stringify(completed));
      console.log('âœ… Added to seller completed orders with rejection flag');
    } catch (e) {
      console.warn('Seller local update failed', e);
    }

    // 5. REFRESH UI
    renderOrders();
    if (typeof renderCompletedOrders === 'function') renderCompletedOrders();
    if (typeof renderAnalytics === 'function') renderAnalytics();

    showToast(`Order rejected. Value: GHC ${totalValue.toFixed(2)} was cancelled.`, 'warn');
    console.log('ðŸŽ‰ rejectOrder completed with financial tracking');

  } catch (err) {
    console.error('âŒ rejectOrder failed', err);
    showToast('Error rejecting order', 'error');
  }
}

/* ---------- Complete Order (move to completedOrders and count revenue) ---------- */
function completeOrder(orderObj){
  orders = JSON.parse(localStorage.getItem(ordersKey())||'[]')||[];
  completedOrders = JSON.parse(localStorage.getItem(completedOrdersKey())||'[]')||[];

  const idx = orders.findIndex(o => (String(o.id) && String(o.id)===String(orderObj.id)) || (String(o.orderId) && String(o.orderId)===String(orderObj.orderId)));
  if(idx === -1) {
    showToast('Order not found to complete','error');
    return;
  }

  const order = {...orders[idx], status: 'Delivered', progressStep: getProgressStep('delivered'), deliveredAt: nowISO()};

  // push to completedOrders and remove from active orders
  completedOrders.push(order);
  orders.splice(idx,1);

  saveWithCloudSync(ordersKey(), orders);
  saveWithCloudSync(completedOrdersKey(), completedOrders);

  // update trackers so polling/storage logic stays consistent
  lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';
  localStorage._lastCompletedJson = localStorage.getItem(completedOrdersKey()) || '[]';

  renderOrders();
  renderProducts();
  renderCompletedOrders();
  renderAnalytics();
  showToast(`Order ${order.id || order.orderId} completed & moved to history`, 'success');

  // notify other tabs
  window.dispatchEvent(new CustomEvent('orderDelivered', { detail: { orderId: order.id || order.orderId } }));
}

/* ---------- Delivery Code Modal (code shown to buyer only) ---------- */
let currentDeliveryOrder = null;
function openConfirmCodeModal(order){
  const orderId = order.id || order.orderId;
  
  // ðŸ”¥ CHECK IF ORDER IS LOCKED (same as delivery page)
  const lockKey = `delivery_lock__${getUid()}__${orderId}`;
  try {
    const lockState = JSON.parse(localStorage.getItem(lockKey) || '{}');
    const lockUntil = lockState.lockUntil || 0;
    
    if (lockUntil > Date.now()) {
      const minutesLeft = Math.ceil((lockUntil - Date.now()) / 60000);
      showToast(
        `ðŸš« Order locked for ${minutesLeft} minutes - Courier failed delivery code too many times`, 
        'error'
      );
      return; // ðŸš« BLOCK SELLER TOO
    }
  } catch (e) {
    console.warn('Lock check failed:', e);
  }
  
  currentDeliveryOrder = order;
  if (deliveryCodeInput) deliveryCodeInput.value = '';
  codeModal.style.display = 'flex';
}

confirmDeliveryBtn && confirmDeliveryBtn.addEventListener('click', async () => {
  if (!currentDeliveryOrder) return;

  // ðŸ”¥ CLEAR THE LOCK ON SUCCESS (same key as delivery page)
  const orderId = currentDeliveryOrder.id || currentDeliveryOrder.orderId;
  try {
    const lockKey = `delivery_lock__${getUid()}__${orderId}`;
    localStorage.removeItem(lockKey);
  } catch (e) {
    console.warn('Failed to clear lock:', e);
  }
  
  // Reload from GLOBAL storage to ensure we have latest version
  const globalOrders = getGlobalOrders();
  const globalIdx = globalOrders.findIndex(o => 
    (o.id && o.id === currentDeliveryOrder.id) || 
    (o.orderId && o.orderId === currentDeliveryOrder.orderId)
  );
  
  if (globalIdx === -1) {
    showToast('Order not found in global storage', 'error');
    return;
  }

  const stored = globalOrders[globalIdx];

  // --- Verify delivery code ---
  if (deliveryCodeInput.value.trim() === String(stored.deliveryCode)) {
    // âœ… Mark as delivered in GLOBAL
    stored.status = 'Delivered';
    stored.progressStep = 6;
    stored.deliveredAt = new Date().toISOString();
    
    // Add to history
    if (!stored.history) stored.history = [];
    stored.history.push({
      from: stored.status,
      to: 'Delivered',
      by: 'seller', 
      at: stored.deliveredAt
    });
    
    // Save to global
    globalOrders[globalIdx] = stored;
    saveGlobalOrders(globalOrders);

    // --- ðŸ”¥ CRITICAL FIX: Sync to Delivery Guy's Storage ---
    try {
      const assignedCourierId = stored.assignedTo || stored.assignedDeliveryId;
      if (assignedCourierId) {
        const deliveryGuyOrdersKey = `orders__delivery__${assignedCourierId}`;
        const deliveryGuyOrders = JSON.parse(localStorage.getItem(deliveryGuyOrdersKey) || '[]');
        
        const deliveryIdx = deliveryGuyOrders.findIndex(o => 
          String(o.id) === String(orderId) || String(o.orderId) === String(orderId)
        );
        
        if (deliveryIdx !== -1) {
          // Update the delivery guy's copy
          deliveryGuyOrders[deliveryIdx] = {
            ...deliveryGuyOrders[deliveryIdx],
            status: 'Delivered',
            progressStep: 6,
            deliveredAt: stored.deliveredAt,
            // Preserve earnings data
            courierEarnings: deliveryGuyOrders[deliveryIdx].courierEarnings || stored.courierEarnings,
            assignedBidAmount: deliveryGuyOrders[deliveryIdx].assignedBidAmount || stored.assignedBidAmount,
            // Add history entry
            history: [
              ...(deliveryGuyOrders[deliveryIdx].history || []),
              {
                action: 'delivery_confirmed_by_seller',
                at: stored.deliveredAt,
                note: 'Seller confirmed delivery with code'
              }
            ]
          };
          
          // Save back to delivery guy's storage
          localStorage.setItem(deliveryGuyOrdersKey, JSON.stringify(deliveryGuyOrders));
          
          // ðŸš¨ NOTIFY DELIVERY GUY TO REFRESH
          localStorage.setItem(`orders_ping__delivery__${assignedCourierId}`, Date.now().toString());
          
          console.log('âœ… Synced "Delivered" status to delivery guy:', assignedCourierId);
        }
      }
    } catch (error) {
      console.warn('Failed to sync to delivery guy:', error);
    }

    // --- Sync to buyer ---
    try {
      const buyerUid = stored?.buyer?.uid || stored?.buyerId || null;
      if (buyerUid) {
        // Update buyer's local orders
        const buyerOrdersKey = `orders__buyer__${buyerUid}`;
        const buyerOrders = JSON.parse(localStorage.getItem(buyerOrdersKey) || '[]');
        const bIdx = buyerOrders.findIndex(o => String(o.id) === String(stored.id));
        
        if (bIdx !== -1) {
          buyerOrders[bIdx].status = 'Delivered';
          buyerOrders[bIdx].progressStep = 6;
          buyerOrders[bIdx].deliveredAt = stored.deliveredAt;
        }
        localStorage.setItem(buyerOrdersKey, JSON.stringify(buyerOrders));
        
        // Ping buyer
        localStorage.setItem(`orders_ping__buyer__${buyerUid}`, String(Date.now()));
      }
    } catch (err) {
      console.warn('Buyer delivery sync failed', err);
    }

    // --- Update seller local storage ---
    try {
      let sellerOrders = JSON.parse(localStorage.getItem(ordersKey()) || '[]');
      const sIdx = sellerOrders.findIndex(o => 
        String(o.id) === String(stored.id) || String(o.orderId) === String(stored.orderId)
      );
      if (sIdx !== -1) {
        sellerOrders[sIdx].status = 'Delivered';
        sellerOrders[sIdx].progressStep = 6;
        localStorage.setItem(ordersKey(), JSON.stringify(sellerOrders));
      }
    } catch(e) {
      console.warn('Seller local update failed', e);
    }

    // --- Continue with normal completeOrder logic ---
    completeOrder(stored);
    codeModal.style.display = 'none';
    currentDeliveryOrder = null;
    showToast('Order marked as Delivered!', 'success');

  } else {
    // âŒ Wrong code entered
    showToast('Incorrect code', 'error');
    stored.attempts = (Number(stored.attempts) || 0) + 1;
    
    // Add to history
    if (!stored.history) stored.history = [];
    stored.history.push({
      action: 'failed_code_attempt',
      attempts: stored.attempts,
      at: new Date().toISOString()
    });
    
    // Save back to global
    globalOrders[globalIdx] = stored;
    saveGlobalOrders(globalOrders);

    if (stored.attempts >= 3) {
      changeOrderStatus(stored, 'Rejected');
      showToast('Too many failed attempts â€” order marked Rejected', 'warn');
    }
  }
});

cancelDeliveryBtn && cancelDeliveryBtn.addEventListener('click', () => {
  // Close modal, keep order untouched so seller can retry entering code
  codeModal.style.display = 'none';
  currentDeliveryOrder = null;
  showToast('Delivery confirmation cancelled â€” you can re-open modal to try again', 'info');
});
/* ---------- Analytics ---------- */
/* ---------- Enhanced Analytics Function ---------- */
function renderAnalytics(){
  completedOrders = JSON.parse(localStorage.getItem(completedOrdersKey()) || '[]') || [];
  orders = JSON.parse(localStorage.getItem(ordersKey()) || '[]') || [];
  products = JSON.parse(localStorage.getItem(productsKey()) || '[]') || [];

  // ðŸŽ¯ ENHANCED: Track different types of revenue
  let totalProductRevenue = 0;
  let totalDeliveryProfit = 0;
  let totalCourierEarnings = 0;
  let totalDeliveryFeesCollected = 0;
  let totalCancelledValue = 0;
  
  let deliveredCount = 0;
  let rejectedCount = 0;
  let pendingCount = 0;
  
  completedOrders.forEach(o => {
    const isRejected = o.status === 'Rejected';
    const isDelivered = o.status === 'Delivered' || o.status === 'Picked Up';
    
    if (isRejected) {
      rejectedCount++;
      const orderValue = o.subtotal + (o.delivery || o.deliveryFee || 0);
      totalCancelledValue += orderValue;
    } else if (isDelivered) {
      deliveredCount++;
      const productRevenue = o.subtotal || 0;
      const deliveryFee = o.delivery || o.deliveryFee || 0;
      const courierEarnings = o.courierEarnings || o.assignedBidAmount || 0;
      const deliveryProfit = o.deliveryProfit || (deliveryFee - courierEarnings);
      
      totalProductRevenue += productRevenue;
      totalDeliveryProfit += deliveryProfit;
      totalCourierEarnings += courierEarnings;
      totalDeliveryFeesCollected += deliveryFee;
    }
  });

  const totalSales = totalProductRevenue + totalDeliveryProfit;
  const pending = orders.filter(o=>(o.status||'').toLowerCase()==='pending').length;
  pendingCount = pending;
  
  const active = products.filter(p=>p.status==='Active').length;
  const stock = products.reduce((s,p)=> s + (Number(p.quantity)||0), 0);
  const totalOrdersCount = (orders.length || 0) + (completedOrders.length || 0);

  // Update the analytics display with more details
  qs('#cardTotal').innerHTML = `GHC ${Number(totalSales||0).toFixed(2)}<br><span class="small-muted" style="font-size:0.75rem">(${deliveredCount} delivered)</span>`;
  qs('#cardOrders').innerHTML = `${totalOrdersCount}<br><span class="small-muted" style="font-size:0.75rem">${rejectedCount} rejected</span>`;
  qs('#cardPending').innerHTML = `${pendingCount}<br><span class="small-muted" style="font-size:0.75rem">active</span>`;
  qs('#cardActive').innerHTML = `${active}<br><span class="small-muted" style="font-size:0.75rem">listings</span>`;
  qs('#cardStock').innerHTML = `${stock}<br><span class="small-muted" style="font-size:0.75rem">units</span>`;

  // Optional: Add a new card for cancelled value
  const cancelledCard = document.createElement('div');
  cancelledCard.innerHTML = `
    <strong>Cancelled Value</strong>
    <div class="small-muted" style="color:var(--danger)">GHC ${Number(totalCancelledValue||0).toFixed(2)}</div>
  `;
  
  const analyticsGrid = document.querySelector('#sectionAnalytics .analytics-grid') || 
                       document.querySelector('#sectionAnalytics > div');
  if (analyticsGrid && !document.querySelector('#cancelledValueCard')) {
    cancelledCard.id = 'cancelledValueCard';
    analyticsGrid.appendChild(cancelledCard);
  }
}

/* ---------- CSV export for completedOrders ---------- */
function exportCompletedCSV(){
  // Get completed orders including rejected ones
  completedOrders = JSON.parse(localStorage.getItem(completedOrdersKey()) || '[]') || [];
  
  if (!completedOrders.length) { 
    showToast('No completed orders to export','warn'); 
    return; 
  }

  const rows = [];
  
  // Enhanced headers with more financial and delivery details
  rows.push([
    'Order ID', 'Status', 'Buyer Name', 'Buyer Email', 'Buyer Phone', 
    'Room', 'Index', 'Program', 'Items Summary', 'Item Details', 
    'Quantity', 'Subtotal', 'Delivery Fee', 'Courier Earnings', 
    'Delivery Profit', 'Seller Revenue', 'Total Order Value',
    'Order Status', 'Placed At', 'Delivered At', 'Rejected At', 'Picked Up At',
    'Assigned Courier', 'Delivery Type', 'Delivery Code', 'Thumbnail URLs', 
    'Order Notes', 'Payment Method', 'Seller Profit/Loss'
  ]);

  // Track summary statistics
  let totalDeliveredRevenue = 0;
  let totalRejectedValue = 0;
  let deliveredCount = 0;
  let rejectedCount = 0;
  let pickupCount = 0;
  let deliveryCount = 0;

  completedOrders.forEach(o => {
    const items = Array.isArray(o.items) ? o.items : (o.product ? [{name:o.product,price:o.price||0,quantity:o.quantity||1, image: orderThumbnail(o)}] : []);
    
    // Enhanced item information
    const itemsSummary = items.map(i => i.name).join('; ');
    const itemDetails = items.map(i => 
      `${i.name} (Qty: ${i.quantity || 1}, Price: GHC ${(i.price || 0).toFixed(2)})`
    ).join(' | ');
    
    const qty = items.reduce((s,i) => s + (Number(i.quantity) || 0), 0);
    const subtotal = o.subtotal || items.reduce((s,i) => s + (Number(i.price) || 0) * (Number(i.quantity) || 1), 0);
    const deliveryFee = o.delivery || o.deliveryFee || 0;
    const totalOrderValue = o.total || (subtotal + deliveryFee);
    
    // Determine order status
    const isRejected = o.status === 'Rejected';
    const isDelivered = o.status === 'Delivered';
    const isPickedUp = o.status === 'Picked Up';
    const deliveryType = o.deliveryType || (isPickedUp ? 'pickup' : 'delivery');
    
    // Calculate financials based on status
    let courierEarnings = 0;
    let deliveryProfit = 0;
    let sellerRevenue = 0;
    let sellerProfitLoss = '';
    
    if (isRejected) {
      // REJECTED ORDER
      sellerRevenue = 0;
      courierEarnings = 0;
      deliveryProfit = 0;
      sellerProfitLoss = 'REJECTED (GHC 0.00)';
      totalRejectedValue += totalOrderValue;
      rejectedCount++;
    } else if (isDelivered || isPickedUp) {
      // DELIVERED OR PICKED UP ORDER
      courierEarnings = o.courierEarnings || o.assignedBidAmount || 0;
      deliveryProfit = o.deliveryProfit || (deliveryFee - courierEarnings);
      sellerRevenue = subtotal + deliveryProfit;
      sellerProfitLoss = `PROFIT: GHC ${sellerRevenue.toFixed(2)}`;
      totalDeliveredRevenue += sellerRevenue;
      deliveredCount++;
      
      if (isPickedUp) {
        pickupCount++;
      } else {
        deliveryCount++;
      }
    } else {
      // OTHER STATUS (shouldn't happen in completed)
      sellerRevenue = 0;
      courierEarnings = 0;
      deliveryProfit = 0;
      sellerProfitLoss = 'UNKNOWN';
    }
    
    const thumbs = items.map(i => i.image || '').filter(Boolean).join('|');

    // Enhanced buyer information
    const buyerObj = (o.buyer && typeof o.buyer === 'object') ? o.buyer : null;
    const buyerName = buyerObj?.name || o.buyerName || o.buyer || o.customer || 'Unknown';
    const buyerPhone = buyerObj?.phone || o.phone || '';
    const buyerEmail = buyerObj?.email || o.email || '';
    const buyerRoom = buyerObj?.room || buyerObj?.roomNumber || buyerObj?.roomnumber || o.room || '';
    const buyerIndex = buyerObj?.index || o.index || '';
    const buyerProgram = buyerObj?.program || '';

    // Enhanced order metadata
    const status = o.status || 'Unknown';
    const assignedCourier = o.deliveryPerson || o.assignedTo || '';
    const deliveryCode = o.deliveryCode || '';
    const orderNotes = (o.notes || o.specialInstructions || '').replace(/,/g, ';'); // Replace commas to avoid CSV issues
    const paymentMethod = o.paymentMethod || 'Unknown';

    // Format dates properly
    const formatDateForCSV = (dateString) => {
      if (!dateString) return '';
      try {
        return new Date(dateString).toLocaleString('en-GB', {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          hour12: false
        });
      } catch {
        return dateString;
      }
    };

    // Create CSV row with all data
    rows.push([
      String(o.id || o.orderId || 'N/A'),
      status,
      buyerName,
      buyerEmail,
      buyerPhone,
      buyerRoom,
      buyerIndex,
      buyerProgram,
      itemsSummary,
      itemDetails,
      String(qty),
      Number(subtotal || 0).toFixed(2),
      Number(deliveryFee || 0).toFixed(2),
      Number(courierEarnings || 0).toFixed(2),
      Number(deliveryProfit || 0).toFixed(2),
      Number(sellerRevenue || 0).toFixed(2),
      Number(totalOrderValue || 0).toFixed(2),
      o.status,
      formatDateForCSV(o.date || o.appearedAt || o.createdAt),
      isDelivered ? formatDateForCSV(o.deliveredAt || o.delivered || o.completedAt) : '',
      isRejected ? formatDateForCSV(o.rejectedAt) : '',
      isPickedUp ? formatDateForCSV(o.pickedUpAt) : '',
      assignedCourier,
      deliveryType,
      deliveryCode,
      thumbs,
      orderNotes,
      paymentMethod,
      sellerProfitLoss
    ]);
  });

  // Add summary rows at the end
  rows.push([]); // Empty row for separation
  rows.push(['SUMMARY', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']);
  rows.push(['Total Orders:', completedOrders.length]);
  rows.push(['Delivered Orders:', deliveredCount]);
  rows.push(['Rejected Orders:', rejectedCount]);
  rows.push(['Pickup Orders:', pickupCount]);
  rows.push(['Delivery Orders:', deliveryCount]);
  rows.push(['Total Delivered Revenue:', `GHC ${totalDeliveredRevenue.toFixed(2)}`]);
  rows.push(['Total Rejected Value:', `GHC ${totalRejectedValue.toFixed(2)}`]);
  rows.push(['Average Revenue per Order:', `GHC ${(totalDeliveredRevenue / (deliveredCount || 1)).toFixed(2)}`]);
  rows.push(['Export Date:', new Date().toLocaleString()]);

  // Enhanced CSV formatting with better handling of special characters
  const csv = rows.map(r => r.map(cell => {
    if (cell === null || typeof cell === 'undefined') return '';
    
    const cellString = String(cell);
    
    // Escape cells that contain commas, quotes, or newlines
    if (/[",\n\r]/.test(cellString)) {
      return `"${cellString.replace(/"/g, '""')}"`;
    }
    
    return cellString;
  }).join(',')).join('\n');

  // Create and trigger download with better error handling
  try {
    const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8;' }); // BOM for Excel compatibility
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    
    const ts = new Date().toISOString()
      .replace(/[:.]/g, '-')
      .replace('T', '_')
      .slice(0, 19); // Better timestamp format: YYYY-MM-DD_HH-MM-SS
    
    a.download = `Marketplace_Orders_${ts}.csv`;
    
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    // Enhanced success message with summary
    showToast(`âœ… Exported ${completedOrders.length} orders (${deliveredCount} delivered, ${rejectedCount} rejected)`, 'success');
    
    // Log export summary for debugging
    console.log('ðŸ“Š CSV Export Summary:', {
      totalOrders: completedOrders.length,
      deliveredCount,
      rejectedCount,
      pickupCount,
      deliveryCount,
      totalDeliveredRevenue: totalDeliveredRevenue.toFixed(2),
      totalRejectedValue: totalRejectedValue.toFixed(2),
      averageRevenue: (totalDeliveredRevenue / (deliveredCount || 1)).toFixed(2),
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('CSV export failed:', error);
    showToast('Failed to export CSV. Please try again.', 'error');
  }
}


/* ---------- Event Listeners ---------- */
productSearch && productSearch.addEventListener('input', renderProducts);
productStatusFilter && productStatusFilter.addEventListener('change', renderProducts);
productCategoryFilter && productCategoryFilter.addEventListener('change', renderProducts);
orderSearch && orderSearch.addEventListener('input', renderOrders);
orderFilter && orderFilter.addEventListener('change', renderOrders);
historySearch && historySearch.addEventListener('input', renderCompletedOrders);
exportCsvBtn && exportCsvBtn.addEventListener('click', exportCompletedCSV);

window.addEventListener('storage',(e)=>{
  if (e.key === ordersKey()) {
    const prev = JSON.parse(lastOrdersJson || '[]');
    const cur = JSON.parse(localStorage.getItem(ordersKey()) || '[]');
    const prevLen = Array.isArray(prev) ? prev.length : 0;
    const curLen = Array.isArray(cur) ? cur.length : 0;
    lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';
    renderOrders(curLen > prevLen);
  } else if (e.key === productsKey()) {
    products = JSON.parse(localStorage.getItem(productsKey())||'[]');
    renderProducts(); renderAnalytics();
  } else if (e.key === completedOrdersKey()) {
    renderCompletedOrders(); renderAnalytics();
    renderOrders();
  }
});
// When global orders change, refresh the page
// When global orders change, refresh the page
window.addEventListener('storage', (e) => {
  if (e.key === ORDERS_GLOBAL) {
    console.log('ðŸ”„ Global orders updated - syncing to seller');
    syncSellerOrdersFromGlobal();
    renderOrders(); // Refresh the display
    showToast('Order status updated from delivery!', 'success');
  }
});

// React to events dispatched by delivery page (immediate sync)
window.addEventListener('localOrdersUpdated', ()=> { renderOrders(); renderCompletedOrders(); renderAnalytics(); });
window.addEventListener('orderDelivered', (e) => { 
  renderOrders(); renderCompletedOrders(); renderAnalytics(); 
  // small toast referencing delivered orderId if present
  try { const id = e?.detail?.orderId; if (id) showToast(`Order ${id} delivered`,'success'); } catch(e){}
});

/* ---------- Polling fallback ---------- */
(function startPollingFallback() {
  setInterval(() => {
    try {
      const curOrdersJson = localStorage.getItem(ordersKey()) || '[]';
      if (curOrdersJson !== lastOrdersJson) {
        const prev = JSON.parse(lastOrdersJson || '[]');
        const cur  = JSON.parse(curOrdersJson || '[]');
        const prevLen = Array.isArray(prev) ? prev.length : 0;
        const curLen  = Array.isArray(cur) ? cur.length : 0;
        lastOrdersJson = curOrdersJson;
        renderOrders(curLen > prevLen);
      }
      const curCompleted = localStorage.getItem(completedOrdersKey()) || '[]';
      if (curCompleted !== (localStorage._lastCompletedJson || '[]')) {
        localStorage._lastCompletedJson = curCompleted;
        renderCompletedOrders();
        renderAnalytics();
        renderOrders();
      }
      const curProducts = localStorage.getItem(productsKey()) || '[]';
      if (curProducts !== (localStorage._lastProductsJson || '[]')) {
        localStorage._lastProductsJson = curProducts;
        products = JSON.parse(curProducts || '[]');
        renderProducts();
        renderAnalytics();
      }
    } catch (err) {
      console.warn('poll error', err);
    }
  }, 1000);
})();

/* ---------- Init ---------- */
function init(){
  products = JSON.parse(localStorage.getItem(productsKey())||'[]')||[];
  orders = JSON.parse(localStorage.getItem(ordersKey())||'[]')||[];
  completedOrders = JSON.parse(localStorage.getItem(completedOrdersKey())||'[]')||[];

  populateCategorySelects();

  let changed = false;
  orders.forEach((o, idx)=>{ 
    orders[idx] = normalizeOrderFields(o);
    if(typeof orders[idx].progressStep==='undefined') { orders[idx].progressStep=getProgressStep(orders[idx].status); changed = true; }
    if(!orders[idx].deliveryCode) { assignDeliveryCode(orders[idx]); changed = true; }
    if(!orders[idx].appearedAt) { ensureAppearedAt(orders[idx]); changed = true; }
  });
  if (changed) saveWithCloudSync(ordersKey(), orders);

  lastOrdersJson = localStorage.getItem(ordersKey()) || '[]';
  localStorage._lastCompletedJson = localStorage.getItem(completedOrdersKey()) || '[]';
  localStorage._lastProductsJson = localStorage.getItem(productsKey()) || '[]';

  // renderProducts is async; we can call it without await here.
  renderProducts();
  renderOrders();
  renderCompletedOrders();
  renderAnalytics();
}
init();

/* ---------- Console helpers ---------- */
window.__sellerDash = {
  get products(){ return JSON.parse(localStorage.getItem(productsKey())||'[]'); },
  get orders(){ return JSON.parse(localStorage.getItem(ordersKey())||'[]'); },
  get completedOrders(){ return JSON.parse(localStorage.getItem(completedOrdersKey())||'[]'); },
  renderProducts, renderOrders, renderCompletedOrders, changeOrderStatus, rejectOrder, completeOrder, exportCompletedCSV,
  // new helpers
  askForDelivery, cancelDeliveryRequest, addBid, removeBid, assignCourier, pushOrderHistory, normalizeOrderFields
};

// ============================================
// âœ… NEW STORAGE CLEANUP FUNCTION - ADD THIS
// ============================================
function optimizeStorageAndCleanup() {
  try {
    console.log('ðŸ” Checking storage for cleanup...');
    
    // Get all current products
    const products = JSON.parse(localStorage.getItem(productsKey()) || '[]');
    
    // If we have more than 80 products, clean up
    if (products.length > 80) {
      console.log(`ðŸ§¹ Storage cleanup needed: ${products.length} products found`);
      
      // Sort products by creation date (oldest first)
      const sorted = [...products].sort((a, b) => {
        const dateA = new Date(a.createdAt || 0);
        const dateB = new Date(b.createdAt || 0);
        return dateA - dateB; // Oldest first
      });
      
      // Keep only the newest 60 products
      const productsToKeep = sorted.slice(-60);
      
      // Save back to storage
      localStorage.setItem(productsKey(), JSON.stringify(productsToKeep));
      
      // Show message to user
      const removedCount = products.length - 60;
      showToast(`ðŸ”„ Storage optimized! Removed ${removedCount} old products`, 'warn');
      
      console.log(`âœ… Cleanup completed: Removed ${removedCount} products`);
      return true;
    }
    
    console.log('âœ… Storage is within limits');
    return false;
    
  } catch (error) {
    console.warn('âŒ Storage cleanup failed:', error);
    return false;
  }
}

// ============================================
// âœ… START AUTOMATIC CLEANUP - ADD THIS TOO
// ============================================

// ðŸŽ¯ ADD THIS TO YOUR EXISTING POLLING SECTION
// Look for this code in your script:
// ============================================
// âœ… FIXED: AUTOMATIC STORAGE CLEANUP
// ============================================

// Automatic storage cleanup every 30 seconds
setInterval(() => {
  optimizeStorageAndCleanup();
}, 30000); // Runs every 30 seconds

// Run cleanup 5 seconds after page loads
setTimeout(() => {
  optimizeStorageAndCleanup();
}, 5000);

</script>







</body>
</html>
